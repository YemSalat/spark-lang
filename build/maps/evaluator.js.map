{"version":3,"sources":["module.js","evaluator-contants.js","evaluator-errormanager.js","evaluator-functable.js","evaluator-symboltable.js","evaluator-util.js","evaluator.js"],"names":["module","NAMESPACE","exportModule","importModule","name","obj","Error","checkModule","hasOwnProperty","this","moduleName","DEFAULT_CONSTANTS","LOW","type","value","HIGH","READ","WRITE","errorConvertMaps","operator","+","-","*","/","errorMap","VARIABLE_STATEMENT","type_mismatch","already_exists","does_not_exist","VARIABLE_DECLARATOR","already_initialized","already_declared","FUNCTION_DECLARATION","PARAM_DECLARATOR","duplicate_param","RETURN_STATEMENT","return_outside","IDENTIFIER","BINARY_EXPRESSION","LOGICAL_EXPRESSION","cant_compare","not_a_number","ASSIGNMENT_STATEMENT","UPDATE_EXPRESSION","UNARY_EXPRESSION","not_a_bool","IF_STATEMENT","logError","node","location","errorType","params","errorCategory","errorMessage","i","l","length","paramRegexA","RegExp","paramRegexB","replace","a","b","cMap","console","log","err","error","message","api","table","currentFunc","returns","getTable","reset","getCurrentFunc","enterFunc","exitFunc","funcAddReturn","current","push","getSignature","result","id","getParams","pr","findFunc","signature","addFunc","initLine","start","line","doc","body","initialScope","scopePointer","sc0","sc1","currentScope","setInitialScope","scope","enterScope","exitScope","getScope","num","scNum","findSymbol","tempScope","addSymbol","symbol","it","init","checkScope","numberTypeScale","equalityOperatorMap","signedIntegerLimits","byte","int","long","util","constructVarDeclarator","right","declarations","$$","left","typeCheck","leftType","rightType","iLeft","indexOf","iRight","getParameters","paramArray","checkParamDuplicates","curPram","j","prvParam","isNumber","isEqualityOperator","getIntegerType","number","nmb","parseInt","a_nmb","Math","abs","resType","last","nType","limit","theEvaluator","symbolTable","funcTable","errorManager","__evalNode","method","mType","pNode","evaluate","CompilerError","parse","tree","options","_nd","DOCSTRING","varType","item","initType","cType","varName","variable","cFunc","cParam","argument","curFunc","CALL_STATEMENT","FOR_STATEMENT","FOR_STATEMENT_DECLARATION","BREAK_STATEMENT","CONTINUE_STATEMENT","EXPRESSION_STATEMENT","newNode","expression","LITERAL","BLOCK_STATEMENT","forEach","PROGRAM","test","consequent","alternate"],"mappings":"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","file":"evaluator.js","sourcesContent":["(function (module) {\n\t// const\n\tvar NAMESPACE = 'SPARK_modules';\n\t\n\tif ( module[NAMESPACE] ) {\n\t\treturn;\n\t}\n\t// create namespace\n\tmodule[NAMESPACE] = {};\n\n\t// create import/export functions\n\tif ( !module.exportModule || !module.importModule ) {\n\t\t// export module\n\t\tmodule.exportModule = function (name, obj) {\n\t\t\tif (module[NAMESPACE][name]) {\n\t\t\t\tthrow new Error('Module '+ name +' already exists');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmodule[NAMESPACE][name] = obj;\n\t\t\t}\n\t\t};\n\t\t// import module\n\t\tmodule.importModule = function (name) {\n\t\t\treturn module[NAMESPACE][name];\n\t\t};\n\t\t// check module\n\t\tmodule.checkModule = function (name) {\n\t\t\treturn module[NAMESPACE].hasOwnProperty(name);\n\t\t};\n\t}\n\n\n})(this);","(function (module) {\n  var moduleName = 'DEFAULT_CONSTANTS';\n  if (module.checkModule(moduleName)) {\n    return;\n  }\n  // :: CONSTANTS\n  'use strict';\n  \n  var DEFAULT_CONSTANTS = {\n    LOW: {\n      name: 'LOW',\n      type: 'int',\n      value: 0\n    },\n    HIGH: {\n      name: 'HIGH',\n      type: 'int',\n      value: 1\n    },\n    READ: {\n      name: 'READ',\n      type: 'int',\n      value: 0\n    },\n    WRITE: {\n      name: 'WRITE',\n      type: 'int',\n      value: 1\n    }\n  };\n\n  // :: EXPORT\n  module.exportModule(moduleName, DEFAULT_CONSTANTS);\n})(this);","(function (module) {\n  var moduleName = 'ErrorManager';\n  if (module.checkModule(moduleName)) {\n    return;\n  }\n  // :: ERROR MANAGER\n  'use strict';\n\n  var errorConvertMaps = {\n    operator: {\n      '+' : 'add',\n      '-' : 'subtract',\n      '*' : 'multiply',\n      '/' : 'divide'\n    }\n  };\n\n  var errorMap = {\n    VARIABLE_STATEMENT    : {\n      type_mismatch       :   'variable \"{0}\" does not match type \"{1}\"',\n      already_exists      :   'variable \"{0}\" was already initialized as {1} on line {2}',\n      does_not_exist      :   'variable \"{0}\" is not defined'\n                            },\n    VARIABLE_DECLARATOR   : {\n      already_initialized :   'variable \"{0}\" was already initialized as {1} on line {2}',\n      already_declared    :   'variable \"{0}\" was already declared on line {1}'\n                            },\n    FUNCTION_DECLARATION  : {\n      already_exists      :   'function \"{0}\" was already declared on line {1}'\n                            },\n    PARAM_DECLARATOR      : {\n      duplicate_param     :   'duplicate parameter \"{0}\"'\n                            },\n    RETURN_STATEMENT      : {\n      return_outside      :   'return statement outside function declaration',\n      type_mismatch       :   'return statement type does not match function \"{0}\"'\n                            },\n    IDENTIFIER            : {\n      does_not_exist      :   'variable \"{0}\" does not exist'\n                            },\n    BINARY_EXPRESSION     : {\n      type_mismatch       :   '\"{0}\" operation types do not match, can\\'t {operator: 0} \"{1}\" and \"{2}\"'\n                            },\n    LOGICAL_EXPRESSION    : {\n      type_mismatch       :   'can\\'t compare \"{0}\" and \"{1}\"',\n      cant_compare        :   'can\\'t compare \"{0}\" and \"{1}\"',\n      not_a_number        :   'can use \"{0}\" operator only on numbers'\n                            },\n    ASSIGNMENT_STATEMENT  : {\n      type_mismatch       :   'assignment types mismatch, can\\'t assign \"{0}\" to \"{1}\"'\n                            },\n    UPDATE_EXPRESSION     : {\n      not_a_number        :   'expression is not a number'\n                            },\n    UNARY_EXPRESSION      : {\n      not_a_bool          :   'unary expression must be a boolean'\n                            },\n    IF_STATEMENT          : {\n      not_a_bool          :   'IF condition must be a boolean'\n                            }\n  };\n\n  // error class\n  function CompilerError (name, message, location) {\n    this.name = name;\n    this.message = message;\n    this.location = location;\n  }\n\n  // log error\n  var logError = function(node, location, errorType, params) {\n    var errorCategory = (typeof node === 'string') ? node : node['$$'];\n    var errorMessage = errorMap[errorCategory][errorType];\n    // 'parse' error message\n    if (params) {\n      for (var i=0,l=params.length; i<l; i++) {\n        var parameter = params[i];\n        var paramRegexA = new RegExp('\\\\{[ ]*([a-z]+)[ ]*\\\\:[ ]*'+ i +'[ ]*\\\\}', 'gi');\n        var paramRegexB = new RegExp('\\\\{[ ]*'+ i +'[ ]*\\\\}', 'gi');\n        errorMessage = errorMessage.replace(paramRegexA, function (a, b) {\n          var cMap = errorConvertMaps[b];\n          console.log('>woo>');\n          console.log(a, b);\n          return cMap[params[i]];\n        });\n        errorMessage = errorMessage.replace(paramRegexB, params[i]);\n      }\n    }\n\n    var err = {\n      error: {\n        location: location,\n        message: errorMessage,\n        node: node\n      }\n    }\n    console.log(err.location);\n    console.log(err.message);\n\n    return err;\n  }\n\n  // api\n  var api = {\n    logError: logError\n  }\n\n\n  // :: EXPORT\n  module.exportModule(moduleName, api);\n\n})(this);","(function (module) {\n  var moduleName = 'FuncTable';\n  if (module.checkModule(moduleName)) {\n    return;\n  }\n  // :: FUNCTION TABLE\n  'use strict';\n\n  var table = {};\n  var currentFunc = {\n    node: null,\n    returns: []\n  };\n  \n  var api = {\n    getTable: function () {\n      return table;\n    },\n\n    reset: function () {\n      table = {};\n      currentFunc = {\n        node: null,\n        returns: []\n      };\n    },\n\n    getCurrentFunc: function () {\n      return currentFunc;\n    },\n\n    enterFunc: function (node) {\n      currentFunc.node = node;\n    },\n\n    exitFunc: function () {\n      currentFunc = {\n        node: null,\n        returns: []\n      };\n    },\n\n    funcAddReturn: function (node) {\n      current.returns.push(node);\n    },\n\n    getSignature: function (node) {\n      var result = node.type + '__' + node.id.name + '__';\n      for (var i=0, l=node.params.length; i<l; i++) {\n        result += node.params[i].type + '_';\n      }\n      result += 'fn';\n      return result;\n    },\n\n    getParams: function (params) {\n      var result = [];\n      for (var i=0,l=params.length;i<l;i++) {\n        var pr = params[i];\n        result.push({ type: pr.type, name: pr.id.name });\n      }\n      return result;\n    },\n\n    findFunc: function (node) {\n      var signature = api.getSignature(node);\n      if (table.hasOwnProperty(signature)) {\n        return table[signature];\n      }\n      return null;\n    },\n\n    addFunc: function (node) {\n      var signature = api.getSignature(node);\n      var name = node.id.name;\n      var type = node.type;\n      var params = api.getParams(node.params);\n      var initLine = node.location.start.line;\n      var doc = (node.doc) ? node.doc.body : \"\";\n\n      table[signature] = {\n        name: name,\n        type: type,\n        params: params,\n        initLine: initLine,\n        doc: doc\n      };\n    }\n  }\n  // :: EXPORT\n  module.exportModule(moduleName, api);\n\n})(this);\n","(function (module) {\n  var moduleName = 'SymbolTable';\n  if (module.checkModule(moduleName)) {\n    return;\n  }\n  // :: SYMBOL TABLE\n  'use strict';\n\n  var initialScope = {};\n\n  var scopePointer = 1;\n  var table = {\n    sc0: initialScope,\n    sc1: {}\n  };\n  var currentScope = table['sc' + scopePointer];\n\n  var api = {\n\n    setInitialScope: function (scope) {\n      initialScope = scope;\n      reset();\n    },\n\n    getTable: function() {\n      return table;\n    },\n\n    reset: function () {\n      scopePointer = 1;\n      table = {\n        sc0: initialScope,\n        sc1: {}\n      };\n      currentScope = table['sc' + scopePointer];\n    },\n\n    enterScope: function () {\n      scopePointer += 1;\n      table['sc' + scopePointer] = {};\n      currentScope = table['sc' + scopePointer];\n    },\n\n    exitScope: function () {\n      if (scopePointer > 1) {\n        table['sc' + scopePointer] = null;\n      }\n      scopePointer -= 1;\n      currentScope = table['sc' + scopePointer];\n    },\n\n    getScope: function (num) {\n      var scNum = num || scopePointer;\n      return table['sc' + scNum];\n    },\n\n    findSymbol: function (name) {\n      for (var i = scopePointer; i >= 0; i--) {\n        var tempScope = api.getScope(i);\n        if (tempScope.hasOwnProperty(name)) {\n          return tempScope[name];\n        }\n      }\n      return null;\n    },\n\n    addSymbol: function (symbol, it) {\n      var init = it || symbol.init;\n      var name = symbol.id.name;\n      var value = init.value;\n      var type = init.type;\n      var initLine = symbol.location.start.line;\n\n      currentScope[name] = {\n        name: name,\n        value: value,\n        type: type,\n        initLine: initLine\n      };\n    },\n\n    checkScope: function (name) {\n      if (currentScope.hasOwnProperty(name)) {\n        return currentScope[name];\n      } else {\n        return false;\n      }\n    }  \n  }\n\n  // :: EXPORT\n  module.exportModule(moduleName, api);\n\n})(this);","(function (module) {\n  var moduleName = 'EvaluatorUtil';\n  if (module.checkModule(moduleName)) {\n    return;\n  }\n  // :: UTILS\n  'use strict';\n  var numberTypeScale = ['byte', 'int', 'long', 'float'];\n  var equalityOperatorMap = ['==', '!=', 'is', 'is not'];\n  var signedIntegerLimits = {\n    'byte': 128,\n    'int': 32767,\n    'long': 2147483647\n  };\n  var util = {\n    constructVarDeclarator: function (node) {\n      node['$$'] = 'VARIABLE_STATEMENT';\n      node.type = node.right.type;\n      node.declarations = [\n        {\n          '$$': 'VARIABLE_DECLARATOR',\n          'id': {\n            'location': node.left.location,\n            '$$': 'IDENTIFIER',\n            'name': node.left.name\n          },\n          'location': node.left.location,\n          'init': node.right\n        }\n      ];\n\n      return node;\n    },\n    typeCheck: function (leftType, rightType) {\n      if (!leftType || !rightType) {\n        return false;\n      }\n      // types match - return\n      if (leftType === rightType) {\n        return leftType;\n      }\n\n      // check numbers\n      var iLeft = numberTypeScale.indexOf(leftType);\n      if (iLeft > -1) {\n        var iRight = numberTypeScale.indexOf(rightType);\n        if (iRight > -1) {\n          // promote left type\n          if (iLeft < iRight) {\n            leftType = rightType;\n          }\n          return leftType;\n        }\n        // left is number, right is not\n        return false;\n      }\n\n      return false;\n    },\n    getParameters: function (paramArray) {\n\n    },\n    checkParamDuplicates: function (params) {\n      for (var i=1,l=params.length; i<l; i++) {\n        var curPram = params[i];\n        for (var j=0; j<i; j++) {\n          var prvParam = params[j];\n          if (prvParam.id.name === curPram.id.name) {\n            return curPram;\n          }\n        }\n      }\n      return false;\n    },\n    isNumber: function (type) {\n      return numberTypeScale.indexOf(type) > -1;\n    },\n    isEqualityOperator: function (operator) {\n      return equalityOperatorMap.indexOf(operator) > -1;\n    },\n    getIntegerType: function (number) {\n      var nmb = parseInt(number, 10);\n      var a_nmb = Math.abs(nmb);\n\n      var resType = 'int';\n      var last = signedIntegerLimits['long'];\n\n      for (var nType in signedIntegerLimits) {\n        if (signedIntegerLimits.hasOwnProperty(nType)) {\n          var limit = signedIntegerLimits[nType];\n          if (a_nmb <= limit && last >= limit) {\n            resType = nType;\n            last = limit;\n          }\n        }\n      }\n\n      return resType;\n    }\n  };\n  // :: EXPORT\n  module.exportModule(moduleName, util);\n})(this);","var theEvaluator = (function(module) {\n  'use strict';\n\n  // :: CONSTANTS\n  var DEFAULT_CONSTANTS = module.importModule('DEFAULT_CONSTANTS');\n\n  // :: MODULES\n  var symbolTable = module.importModule('SymbolTable');\n  var funcTable = module.importModule('FuncTable');\n  var errorManager = module.importModule('ErrorManager');\n  var util = module.importModule('EvaluatorUtil');\n\n  // :: OP\n  var __evalNode = function(node, method) {\n    var mType = method || node['$$'];\n    var pNode = evaluate[mType](node)\n    if (pNode.error) {\n      throw new CompilerError('SemanticError', pNode.error.message, pNode.error.location);\n    }\n    return pNode;\n  };\n\n  var api = {\n    parse: function (tree, options) {\n      // reset tables\n      symbolTable.reset(); \n      funcTable.reset();\n\n      var _nd = __evalNode(tree);\n      console.log(symbolTable.getTable());\n\n      return _nd;\n    }\n  };\n\n\n  // :: EVALUATE\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return node;\n    },\n    \n    VARIABLE_STATEMENT: function(node) {\n      var varType = node.type;\n\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n        \n        // eval right side\n        var initType = null;\n        if (item.init !== null) {\n          item.init = __evalNode(item.init);\n          // check types\n          var cType = util.typeCheck(node.type, item.init.type);\n          if (!cType) {\n            return errorManager.logError(node, node.location, 'type_mismatch', [item.id.name, varType]);\n          }\n          else {\n            node.type = cType;\n          }\n          initType = cType;\n        }\n        // set identifier type\n        item.type = initType;\n        // check if variable exists\n        var varName = item.id.name;\n        var variable = symbolTable.checkScope(varName);\n        if (variable) {\n          // error\n          return errorManager.logError(node, node.location, 'already_exists', [item.id.name, variable.value, variable.initLine]);\n        }\n        else {\n          // add new variable to current scope\n          symbolTable.addSymbol(item, { value: null, type: node.type });\n        }\n      }\n\n      return node;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n\n    FUNCTION_DECLARATION: function (node) {\n      var cFunc = funcTable.findFunc(node);\n      if (cFunc) {\n        // error\n        return errorManager.logError(node, node.location, 'already_exists', [cFunc.name, cFunc.initLine]);\n      }\n\n      // check duplicate params\n      var cParam = util.checkParamDuplicates(node.params);\n      if (cParam) {\n        return errorManager.logError(cParam, cParam.location, 'duplicate_param', [cParam.id.name]);\n      }\n\n      funcTable.addFunc(node);\n\n      // increase current scope\n      symbolTable.enterScope();\n      // enter function (used for return check)\n      funcTable.enterFunc(node);\n      // parse function body\n      node.body = __evalNode(node.body);\n      // exit function\n      funcTable.exitFunc();\n      // exit scope\n      symbolTable.exitScope();\n\n      return node;\n    },\n    PARAM_DECLARATOR: function (node) {\n      return node;\n    },\n    RETURN_STATEMENT: function (node) {\n      node.argument = __evalNode(node.argument);\n      // set return statement type\n      node.type = node.argument.type;\n\n      // check type matches current function\n      var curFunc = getCurrentFunc();\n      if (!curFunc.node) {\n        return errorManager.logError(node, node.location, 'return_outside');\n      }\n      var cType = util.typeCheck(node.type, curFunc.type);\n      if (!cType) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [curFunc.node.id.name]);\n      }\n\n      return node;\n    },\n    CALL_STATEMENT: function (node) {\n      node.type = 'int';\n      return node;\n    },\n\n\n\n    FOR_STATEMENT: function (node) {\n      return node;\n    },\n\n    FOR_STATEMENT_DECLARATION: function (node) {\n      return node;\n    },\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n\n    EXPRESSION_STATEMENT: function (node) {\n      var newNode = __evalNode(node.expression);\n      return newNode;\n    },\n\n    IDENTIFIER: function (node) {\n      // check if variable exists\n      var varName = node.name;\n      var variable = symbolTable.findSymbol(varName);\n      if (variable) {\n        // assign node type\n        node.type = variable.type;\n      } else {\n        // error\n        return errorManager.logError(node, node.location, 'does_not_exist', [varName]);\n      }\n\n      return node;\n    },\n\n    LITERAL: function(node) {\n      // convert int type\n      if (node.type === 'int') {\n        node.type = util.getIntegerType(node.value);\n      }\n\n      return node;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      // eval left and right parts first\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n      // assign node type\n      // check types\n      node.type = util.typeCheck(node.left.type, node.right.type);\n      // error\n      if (!node.type) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.operator, node.left.type, node.right.type]);\n      }\n      return node;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      // eval asignment right hand side\n      node.right = __evalNode(node.right);\n      // check if variable exists\n      var varName = node.left.name;\n      var variable = symbolTable.findSymbol(varName);\n      if (!variable) {\n        // eval as variable statement instead\n        return __evalNode(util.constructVarDeclarator(node));\n      }\n      // eval left hand side\n      node.left = __evalNode(node.left);\n\n      // check types\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.right.type, node.left.type]);\n      }\n\n      return node;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      // increase current scope\n      symbolTable.enterScope();\n\n      node.body.forEach(function(item) {\n        item = __evalNode(item);\n      });\n\n      // decrease scope\n      symbolTable.exitScope();\n      \n      return node;\n    },\n\n    PROGRAM: function (node) {\n\n      node.body.forEach(function(item) {\n        item = __evalNode(item);\n      });\n      \n      return node;\n    },\n\n    IF_STATEMENT: function (node) {\n      // parse test condition\n      node.test = __evalNode(node.test);\n      // check test type\n      if (node.test.type !== 'bool') {\n        return errorManager.logError(node, node.test.location, 'not_a_bool');\n      }\n\n      // parse consequent and alternate\n      node.consequent = __evalNode(node.consequent);\n      if (node.alternate) {\n        node.alternate = __evalNode(node.alternate);\n      }\n      return node;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n\n      // check types\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        // error\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.left.type, node.right.type]);\n      }\n      else if (!util.isEqualityOperator(node.operator) && !util.isNumber(cType)) {\n        // cant compare\n        return errorManager.logError(node, node.location, 'not_a_number', [node.operator]);\n      }\n      return node;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      node.argument = __evalNode(node.argument);\n      if (!util.isNumber(node.argument.type)) {\n        // error\n        return errorManager.logError(node, node.location, 'not_a_number');\n      }\n      node.type = node.argument.type; \n      return node;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      node.argument = __evalNode(node.argument);\n      var cType = util.typeCheck(node.argument.type);\n      if (cType !== 'bool') {\n        // error\n        return errorManager.logError(node, node.location, 'not_a_bool');\n      }\n      return node;\n    }\n\n  };\n\n  // :: SPARK EVALUATOR\n  return api;\n\n})(this);"],"sourceRoot":"/source/"}