{"version":3,"sources":["node_modules/browser-pack/_prelude.js","evaluator.js","src/evaluator/evaluator.js","src/evaluator/modules/DEFAULT_CONSTANTS.js","src/evaluator/modules/ErrorManager.js","src/evaluator/modules/EvaluatorUtil.js","src/evaluator/modules/FuncTable.js","src/evaluator/modules/SymbolTable.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","global","SemanticError","name","message","location","this","symbolTable","funcTable","errorManager","util","DEFAULT_CONSTANTS","setInitialScope","__evalNode","node","method","mType","pNode","evaluate","error","api","parse","tree","options","reset","_tree","symbolScope","getTable","funcScope","DOCSTRING","VARIABLE_STATEMENT","varType","type","declarations","item","initType","init","cType","typeCheck","logError","id","varName","variable","checkScope","value","initLine","addSymbol","VARIABLE_DECLARATOR","FUNCTION_DECLARATION","cFunc","findFunc","cParam","checkParamDuplicates","params","addFunc","enterScope","enterFunc","body","exitFunc","exitScope","PARAM_DECLARATOR","RETURN_STATEMENT","argument","curFunc","getCurrentFunc","CALL_STATEMENT","FOR_STATEMENT","FOR_STATEMENT_DECLARATION","BREAK_STATEMENT","CONTINUE_STATEMENT","EXPRESSION_STATEMENT","newNode","expression","IDENTIFIER","findSymbol","LITERAL","getIntegerType","BINARY_EXPRESSION","left","right","operator","ASSIGNMENT_STATEMENT","constructVarDeclarator","BLOCK_STATEMENT","forEach","PROGRAM","IF_STATEMENT","test","consequent","alternate","LOGICAL_EXPRESSION","isEqualityOperator","isNumber","UPDATE_EXPRESSION","UNARY_EXPRESSION","SparkEvaluator","self","window","./modules/DEFAULT_CONSTANTS","./modules/ErrorManager","./modules/EvaluatorUtil","./modules/FuncTable","./modules/SymbolTable",2,"LOW","HIGH","READ","WRITE",3,"errorConvertMaps","+","-","*","/","errorMap","type_mismatch","already_exists","does_not_exist","already_initialized","already_declared","duplicate_param","return_outside","cant_compare","not_a_number","not_a_bool","errorType","errorCategory","errorMessage","paramRegexA","RegExp","paramRegexB","replace","b","cMap","console","log","err",4,"numberTypeScale","equalityOperatorMap","signedIntegerLimits","byte","int","long","$$","leftType","rightType","iLeft","indexOf","iRight","getParameters","paramArray","curPram","j","prvParam","number","nmb","parseInt","a_nmb","Math","abs","resType","last","nType","hasOwnProperty","limit",5,"table","currentFunc","returns","funcAddReturn","current","push","getSignature","result","getParams","pr","signature","start","line","doc",6,"initialScope","scopePointer","sc0","sc1","currentScope","scope","getScope","num","scNum","tempScope","symbol","it"],"mappings":"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","file":"evaluator.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\nmodule.exports = (function() {\n  'use strict';\n\n  // :: MODULES\n  var symbolTable = require('./modules/SymbolTable')\n  var funcTable = require('./modules/FuncTable');\n  var errorManager = require('./modules/ErrorManager');\n  var util = require('./modules/EvaluatorUtil');\n  \n  // :: CONSTANTS\n  var DEFAULT_CONSTANTS = require('./modules/DEFAULT_CONSTANTS');\n\n  symbolTable.setInitialScope(DEFAULT_CONSTANTS);\n\n  // :: ERRORS\n  function SemanticError (name, message, location) {\n    this.name = name;\n    this.message = message;\n    this.location = location;\n  }\n\n  // :: OP\n  var __evalNode = function(node, method) {\n    var mType = method || node['$$'];\n    var pNode = evaluate[mType](node)\n    if (pNode.error) {\n      throw new SemanticError('SemanticError', pNode.error.message, pNode.error.location);\n    }\n    return pNode;\n  };\n\n  var api = {\n    parse: function (tree, options) {\n      // reset tables\n      symbolTable.reset(); \n      funcTable.reset();\n\n      var _tree = __evalNode(tree);\n\n      return {\n        tree: _tree,\n        symbolScope: symbolTable.getTable(),\n        funcScope: funcTable.getTable()\n      };\n    }\n  };\n\n\n  // :: EVALUATE\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return node;\n    },\n    \n    VARIABLE_STATEMENT: function(node) {\n      var varType = node.type;\n\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n        \n        // eval right side\n        var initType = null;\n        if (item.init !== null) {\n          item.init = __evalNode(item.init);\n          // check types\n          var cType = util.typeCheck(node.type, item.init.type);\n          if (!cType) {\n            return errorManager.logError(node, node.location, 'type_mismatch', [item.id.name, varType]);\n          }\n          else {\n            node.type = cType;\n          }\n          initType = cType;\n        }\n        // set identifier type\n        item.type = initType;\n        // check if variable exists\n        var varName = item.id.name;\n        var variable = symbolTable.checkScope(varName);\n        if (variable) {\n          // error\n          return errorManager.logError(node, node.location, 'already_exists', [item.id.name, variable.value, variable.initLine]);\n        }\n        else {\n          // add new variable to current scope\n          symbolTable.addSymbol(item, { value: null, type: node.type });\n        }\n      }\n\n      return node;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n\n    FUNCTION_DECLARATION: function (node) {\n      var cFunc = funcTable.findFunc(node);\n      if (cFunc) {\n        // error\n        return errorManager.logError(node, node.location, 'already_exists', [cFunc.name, cFunc.initLine]);\n      }\n\n      // check duplicate params\n      var cParam = util.checkParamDuplicates(node.params);\n      if (cParam) {\n        return errorManager.logError(cParam, cParam.location, 'duplicate_param', [cParam.id.name]);\n      }\n\n      funcTable.addFunc(node);\n\n      // increase current scope\n      symbolTable.enterScope();\n      // enter function (used for return check)\n      funcTable.enterFunc(node);\n      // parse function body\n      node.body = __evalNode(node.body);\n      // exit function\n      funcTable.exitFunc();\n      // exit scope\n      symbolTable.exitScope();\n\n      return node;\n    },\n    PARAM_DECLARATOR: function (node) {\n      return node;\n    },\n    RETURN_STATEMENT: function (node) {\n      node.argument = __evalNode(node.argument);\n      // set return statement type\n      node.type = node.argument.type;\n\n      // check type matches current function\n      var curFunc = getCurrentFunc();\n      if (!curFunc.node) {\n        return errorManager.logError(node, node.location, 'return_outside');\n      }\n      var cType = util.typeCheck(node.type, curFunc.type);\n      if (!cType) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [curFunc.node.id.name]);\n      }\n\n      return node;\n    },\n    CALL_STATEMENT: function (node) {\n      node.type = 'int';\n      return node;\n    },\n\n\n\n    FOR_STATEMENT: function (node) {\n      return node;\n    },\n\n    FOR_STATEMENT_DECLARATION: function (node) {\n      return node;\n    },\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n\n    EXPRESSION_STATEMENT: function (node) {\n      var newNode = __evalNode(node.expression);\n      return newNode;\n    },\n\n    IDENTIFIER: function (node) {\n      // check if variable exists\n      var varName = node.name;\n      var variable = symbolTable.findSymbol(varName);\n      if (variable) {\n        // assign node type\n        node.type = variable.type;\n      } else {\n        // error\n        return errorManager.logError(node, node.location, 'does_not_exist', [varName]);\n      }\n\n      return node;\n    },\n\n    LITERAL: function(node) {\n      // convert int type\n      if (node.type === 'int') {\n        node.type = util.getIntegerType(node.value);\n      }\n\n      return node;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      // eval left and right parts first\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n      // assign node type\n      // check types\n      node.type = util.typeCheck(node.left.type, node.right.type);\n      // error\n      if (!node.type) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.operator, node.left.type, node.right.type]);\n      }\n      return node;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      // eval asignment right hand side\n      node.right = __evalNode(node.right);\n      // check if variable exists\n      var varName = node.left.name;\n      var variable = symbolTable.findSymbol(varName);\n      if (!variable) {\n        // eval as variable statement instead\n        return __evalNode(util.constructVarDeclarator(node));\n      }\n      // eval left hand side\n      node.left = __evalNode(node.left);\n\n      // check types\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.right.type, node.left.type]);\n      }\n\n      return node;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      // increase current scope\n      symbolTable.enterScope();\n\n      node.body.forEach(function(item) {\n        item = __evalNode(item);\n      });\n\n      // decrease scope\n      symbolTable.exitScope();\n      \n      return node;\n    },\n\n    PROGRAM: function (node) {\n\n      node.body.forEach(function(item) {\n        item = __evalNode(item);\n      });\n      \n      return node;\n    },\n\n    IF_STATEMENT: function (node) {\n      // parse test condition\n      node.test = __evalNode(node.test);\n      // check test type\n      if (node.test.type !== 'bool') {\n        return errorManager.logError(node, node.test.location, 'not_a_bool');\n      }\n\n      // parse consequent and alternate\n      node.consequent = __evalNode(node.consequent);\n      if (node.alternate) {\n        node.alternate = __evalNode(node.alternate);\n      }\n      return node;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n\n      // check types\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        // error\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.left.type, node.right.type]);\n      }\n      else if (!util.isEqualityOperator(node.operator) && !util.isNumber(cType)) {\n        // cant compare\n        return errorManager.logError(node, node.location, 'not_a_number', [node.operator]);\n      }\n      return node;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      node.argument = __evalNode(node.argument);\n      if (!util.isNumber(node.argument.type)) {\n        // error\n        return errorManager.logError(node, node.location, 'not_a_number');\n      }\n      node.type = node.argument.type; \n      return node;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      node.argument = __evalNode(node.argument);\n      var cType = util.typeCheck(node.argument.type);\n      if (cType !== 'bool') {\n        // error\n        return errorManager.logError(node, node.location, 'not_a_bool');\n      }\n      return node;\n    }\n\n  };\n\n  // :: SPARK EVALUATOR\n  global.SparkEvaluator = api;\n  return api;\n\n})();\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./modules/DEFAULT_CONSTANTS\":2,\"./modules/ErrorManager\":3,\"./modules/EvaluatorUtil\":4,\"./modules/FuncTable\":5,\"./modules/SymbolTable\":6}],2:[function(require,module,exports){\nmodule.exports = (function () {\n  // :: CONSTANTS\n  'use strict';\n  \n  var DEFAULT_CONSTANTS = {\n    LOW: {\n      name: 'LOW',\n      type: 'int',\n      value: 0\n    },\n    HIGH: {\n      name: 'HIGH',\n      type: 'int',\n      value: 1\n    },\n    READ: {\n      name: 'READ',\n      type: 'int',\n      value: 0\n    },\n    WRITE: {\n      name: 'WRITE',\n      type: 'int',\n      value: 1\n    }\n  };\n\n  return DEFAULT_CONSTANTS;\n\n})();\n},{}],3:[function(require,module,exports){\nmodule.exports = (function () {\n  // :: ERROR MANAGER\n  'use strict';\n\n  var errorConvertMaps = {\n    operator: {\n      '+' : 'add',\n      '-' : 'subtract',\n      '*' : 'multiply',\n      '/' : 'divide'\n    }\n  };\n\n  var errorMap = {\n    VARIABLE_STATEMENT    : {\n      type_mismatch       :   'variable \"{0}\" does not match type \"{1}\"',\n      already_exists      :   'variable \"{0}\" was already initialized as {1} on line {2}',\n      does_not_exist      :   'variable \"{0}\" is not defined'\n                            },\n    VARIABLE_DECLARATOR   : {\n      already_initialized :   'variable \"{0}\" was already initialized as {1} on line {2}',\n      already_declared    :   'variable \"{0}\" was already declared on line {1}'\n                            },\n    FUNCTION_DECLARATION  : {\n      already_exists      :   'function \"{0}\" was already declared on line {1}'\n                            },\n    PARAM_DECLARATOR      : {\n      duplicate_param     :   'duplicate parameter \"{0}\"'\n                            },\n    RETURN_STATEMENT      : {\n      return_outside      :   'return statement outside function declaration',\n      type_mismatch       :   'return statement type does not match function \"{0}\"'\n                            },\n    IDENTIFIER            : {\n      does_not_exist      :   'variable \"{0}\" does not exist'\n                            },\n    BINARY_EXPRESSION     : {\n      type_mismatch       :   '\"{0}\" operation types do not match, can\\'t {operator: 0} \"{1}\" and \"{2}\"'\n                            },\n    LOGICAL_EXPRESSION    : {\n      type_mismatch       :   'can\\'t compare \"{0}\" and \"{1}\"',\n      cant_compare        :   'can\\'t compare \"{0}\" and \"{1}\"',\n      not_a_number        :   'can use \"{0}\" operator only on numbers'\n                            },\n    ASSIGNMENT_STATEMENT  : {\n      type_mismatch       :   'assignment types mismatch, can\\'t assign \"{0}\" to \"{1}\"'\n                            },\n    UPDATE_EXPRESSION     : {\n      not_a_number        :   'expression is not a number'\n                            },\n    UNARY_EXPRESSION      : {\n      not_a_bool          :   'unary expression must be a boolean'\n                            },\n    IF_STATEMENT          : {\n      not_a_bool          :   'IF condition must be a boolean'\n                            }\n  };\n\n  // log error\n  var logError = function(node, location, errorType, params) {\n    var errorCategory = (typeof node === 'string') ? node : node['$$'];\n    var errorMessage = errorMap[errorCategory][errorType];\n    // 'parse' error message\n    if (params) {\n      for (var i=0,l=params.length; i<l; i++) {\n        var parameter = params[i];\n        var paramRegexA = new RegExp('\\\\{[ ]*([a-z]+)[ ]*\\\\:[ ]*'+ i +'[ ]*\\\\}', 'gi');\n        var paramRegexB = new RegExp('\\\\{[ ]*'+ i +'[ ]*\\\\}', 'gi');\n        errorMessage = errorMessage.replace(paramRegexA, function (a, b) {\n          var cMap = errorConvertMaps[b];\n          console.log('>woo>');\n          console.log(a, b);\n          return cMap[params[i]];\n        });\n        errorMessage = errorMessage.replace(paramRegexB, params[i]);\n      }\n    }\n\n    var err = {\n      error: {\n        location: location,\n        message: errorMessage,\n        node: node\n      }\n    }\n    console.log(err.location);\n    console.log(err.message);\n\n    return err;\n  }\n\n  // api\n  var api = {\n    logError: logError\n  }\n\n\n  // :: EXPORT\n  return api;\n\n})();\n},{}],4:[function(require,module,exports){\nmodule.exports = (function () {\n  // :: UTILS\n  'use strict';\n  var numberTypeScale = ['byte', 'int', 'long', 'float'];\n  var equalityOperatorMap = ['==', '!=', 'is', 'is not'];\n  var signedIntegerLimits = {\n    'byte': 128,\n    'int': 32767,\n    'long': 2147483647\n  };\n  \n  var api = {\n    constructVarDeclarator: function (node) {\n      node['$$'] = 'VARIABLE_STATEMENT';\n      node.type = node.right.type;\n      node.declarations = [\n        {\n          '$$': 'VARIABLE_DECLARATOR',\n          'id': {\n            'location': node.left.location,\n            '$$': 'IDENTIFIER',\n            'name': node.left.name\n          },\n          'location': node.left.location,\n          'init': node.right\n        }\n      ];\n\n      return node;\n    },\n    typeCheck: function (leftType, rightType) {\n      if (!leftType || !rightType) {\n        return false;\n      }\n      // types match - return\n      if (leftType === rightType) {\n        return leftType;\n      }\n\n      // check numbers\n      var iLeft = numberTypeScale.indexOf(leftType);\n      if (iLeft > -1) {\n        var iRight = numberTypeScale.indexOf(rightType);\n        if (iRight > -1) {\n          // promote left type\n          if (iLeft < iRight) {\n            leftType = rightType;\n          }\n          return leftType;\n        }\n        // left is number, right is not\n        return false;\n      }\n\n      return false;\n    },\n    getParameters: function (paramArray) {\n\n    },\n    checkParamDuplicates: function (params) {\n      for (var i=1,l=params.length; i<l; i++) {\n        var curPram = params[i];\n        for (var j=0; j<i; j++) {\n          var prvParam = params[j];\n          if (prvParam.id.name === curPram.id.name) {\n            return curPram;\n          }\n        }\n      }\n      return false;\n    },\n    isNumber: function (type) {\n      return numberTypeScale.indexOf(type) > -1;\n    },\n    isEqualityOperator: function (operator) {\n      return equalityOperatorMap.indexOf(operator) > -1;\n    },\n    getIntegerType: function (number) {\n      var nmb = parseInt(number, 10);\n      var a_nmb = Math.abs(nmb);\n\n      var resType = 'int';\n      var last = signedIntegerLimits['long'];\n\n      for (var nType in signedIntegerLimits) {\n        if (signedIntegerLimits.hasOwnProperty(nType)) {\n          var limit = signedIntegerLimits[nType];\n          if (a_nmb <= limit && last >= limit) {\n            resType = nType;\n            last = limit;\n          }\n        }\n      }\n\n      return resType;\n    }\n  };\n  // :: EXPORT\n  return api;\n\n})();\n},{}],5:[function(require,module,exports){\nmodule.exports = (function () {\n  // :: FUNCTION TABLE\n  'use strict';\n\n  var table = {};\n  var currentFunc = {\n    node: null,\n    returns: []\n  };\n  \n  var api = {\n    getTable: function () {\n      return table;\n    },\n\n    reset: function () {\n      table = {};\n      currentFunc = {\n        node: null,\n        returns: []\n      };\n    },\n\n    getCurrentFunc: function () {\n      return currentFunc;\n    },\n\n    enterFunc: function (node) {\n      currentFunc.node = node;\n    },\n\n    exitFunc: function () {\n      currentFunc = {\n        node: null,\n        returns: []\n      };\n    },\n\n    funcAddReturn: function (node) {\n      current.returns.push(node);\n    },\n\n    getSignature: function (node) {\n      var result = node.type + '__' + node.id.name + '__';\n      for (var i=0, l=node.params.length; i<l; i++) {\n        result += node.params[i].type + '_';\n      }\n      result += 'fn';\n      return result;\n    },\n\n    getParams: function (params) {\n      var result = [];\n      for (var i=0,l=params.length;i<l;i++) {\n        var pr = params[i];\n        result.push({ type: pr.type, name: pr.id.name });\n      }\n      return result;\n    },\n\n    findFunc: function (node) {\n      var signature = api.getSignature(node);\n      if (table.hasOwnProperty(signature)) {\n        return table[signature];\n      }\n      return null;\n    },\n\n    addFunc: function (node) {\n      var signature = api.getSignature(node);\n      var name = node.id.name;\n      var type = node.type;\n      var params = api.getParams(node.params);\n      var initLine = node.location.start.line;\n      var doc = (node.doc) ? node.doc.body : \"\";\n\n      table[signature] = {\n        name: name,\n        type: type,\n        params: params,\n        initLine: initLine,\n        doc: doc\n      };\n    }\n  }\n  // :: EXPORT\n  return api;\n\n})();\n\n},{}],6:[function(require,module,exports){\nmodule.exports = (function () {\n  // :: SYMBOL TABLE\n  'use strict';\n\n  var initialScope = {};\n\n  var scopePointer = 1;\n  var table = {\n    sc0: initialScope,\n    sc1: {}\n  };\n  var currentScope = table['sc' + scopePointer];\n\n  var api = {\n\n    setInitialScope: function (scope) {\n      initialScope = scope;\n      api.reset();\n    },\n\n    getTable: function() {\n      return table;\n    },\n\n    reset: function () {\n      scopePointer = 1;\n      table = {\n        sc0: initialScope,\n        sc1: {}\n      };\n      currentScope = table['sc' + scopePointer];\n    },\n\n    enterScope: function () {\n      scopePointer += 1;\n      table['sc' + scopePointer] = {};\n      currentScope = table['sc' + scopePointer];\n    },\n\n    exitScope: function () {\n      if (scopePointer > 1) {\n        table['sc' + scopePointer] = null;\n      }\n      scopePointer -= 1;\n      currentScope = table['sc' + scopePointer];\n    },\n\n    getScope: function (num) {\n      var scNum = num || scopePointer;\n      return table['sc' + scNum];\n    },\n\n    findSymbol: function (name) {\n      for (var i = scopePointer; i >= 0; i--) {\n        var tempScope = api.getScope(i);\n        if (tempScope.hasOwnProperty(name)) {\n          return tempScope[name];\n        }\n      }\n      return null;\n    },\n\n    addSymbol: function (symbol, it) {\n      var init = it || symbol.init;\n      var name = symbol.id.name;\n      var value = init.value;\n      var type = init.type;\n      var initLine = symbol.location.start.line;\n\n      currentScope[name] = {\n        name: name,\n        value: value,\n        type: type,\n        initLine: initLine\n      };\n    },\n\n    checkScope: function (name) {\n      if (currentScope.hasOwnProperty(name)) {\n        return currentScope[name];\n      } else {\n        return false;\n      }\n    }  \n  }\n\n  // :: EXPORT\n  return api;\n  \n})();\n},{}]},{},[1])\n\n","module.exports = (function() {\n  'use strict';\n\n  // :: MODULES\n  var symbolTable = require('./modules/SymbolTable')\n  var funcTable = require('./modules/FuncTable');\n  var errorManager = require('./modules/ErrorManager');\n  var util = require('./modules/EvaluatorUtil');\n  \n  // :: CONSTANTS\n  var DEFAULT_CONSTANTS = require('./modules/DEFAULT_CONSTANTS');\n\n  symbolTable.setInitialScope(DEFAULT_CONSTANTS);\n\n  // :: ERRORS\n  function SemanticError (name, message, location) {\n    this.name = name;\n    this.message = message;\n    this.location = location;\n  }\n\n  // :: OP\n  var __evalNode = function(node, method) {\n    var mType = method || node['$$'];\n    var pNode = evaluate[mType](node)\n    if (pNode.error) {\n      throw new SemanticError('SemanticError', pNode.error.message, pNode.error.location);\n    }\n    return pNode;\n  };\n\n  var api = {\n    parse: function (tree, options) {\n      // reset tables\n      symbolTable.reset(); \n      funcTable.reset();\n\n      var _tree = __evalNode(tree);\n\n      return {\n        tree: _tree,\n        symbolScope: symbolTable.getTable(),\n        funcScope: funcTable.getTable()\n      };\n    }\n  };\n\n\n  // :: EVALUATE\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return node;\n    },\n    \n    VARIABLE_STATEMENT: function(node) {\n      var varType = node.type;\n\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n        \n        // eval right side\n        var initType = null;\n        if (item.init !== null) {\n          item.init = __evalNode(item.init);\n          // check types\n          var cType = util.typeCheck(node.type, item.init.type);\n          if (!cType) {\n            return errorManager.logError(node, node.location, 'type_mismatch', [item.id.name, varType]);\n          }\n          else {\n            node.type = cType;\n          }\n          initType = cType;\n        }\n        // set identifier type\n        item.type = initType;\n        // check if variable exists\n        var varName = item.id.name;\n        var variable = symbolTable.checkScope(varName);\n        if (variable) {\n          // error\n          return errorManager.logError(node, node.location, 'already_exists', [item.id.name, variable.value, variable.initLine]);\n        }\n        else {\n          // add new variable to current scope\n          symbolTable.addSymbol(item, { value: null, type: node.type });\n        }\n      }\n\n      return node;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n\n    FUNCTION_DECLARATION: function (node) {\n      var cFunc = funcTable.findFunc(node);\n      if (cFunc) {\n        // error\n        return errorManager.logError(node, node.location, 'already_exists', [cFunc.name, cFunc.initLine]);\n      }\n\n      // check duplicate params\n      var cParam = util.checkParamDuplicates(node.params);\n      if (cParam) {\n        return errorManager.logError(cParam, cParam.location, 'duplicate_param', [cParam.id.name]);\n      }\n\n      funcTable.addFunc(node);\n\n      // increase current scope\n      symbolTable.enterScope();\n      // enter function (used for return check)\n      funcTable.enterFunc(node);\n      // parse function body\n      node.body = __evalNode(node.body);\n      // exit function\n      funcTable.exitFunc();\n      // exit scope\n      symbolTable.exitScope();\n\n      return node;\n    },\n    PARAM_DECLARATOR: function (node) {\n      return node;\n    },\n    RETURN_STATEMENT: function (node) {\n      node.argument = __evalNode(node.argument);\n      // set return statement type\n      node.type = node.argument.type;\n\n      // check type matches current function\n      var curFunc = getCurrentFunc();\n      if (!curFunc.node) {\n        return errorManager.logError(node, node.location, 'return_outside');\n      }\n      var cType = util.typeCheck(node.type, curFunc.type);\n      if (!cType) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [curFunc.node.id.name]);\n      }\n\n      return node;\n    },\n    CALL_STATEMENT: function (node) {\n      node.type = 'int';\n      return node;\n    },\n\n\n\n    FOR_STATEMENT: function (node) {\n      return node;\n    },\n\n    FOR_STATEMENT_DECLARATION: function (node) {\n      return node;\n    },\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n\n    EXPRESSION_STATEMENT: function (node) {\n      var newNode = __evalNode(node.expression);\n      return newNode;\n    },\n\n    IDENTIFIER: function (node) {\n      // check if variable exists\n      var varName = node.name;\n      var variable = symbolTable.findSymbol(varName);\n      if (variable) {\n        // assign node type\n        node.type = variable.type;\n      } else {\n        // error\n        return errorManager.logError(node, node.location, 'does_not_exist', [varName]);\n      }\n\n      return node;\n    },\n\n    LITERAL: function(node) {\n      // convert int type\n      if (node.type === 'int') {\n        node.type = util.getIntegerType(node.value);\n      }\n\n      return node;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      // eval left and right parts first\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n      // assign node type\n      // check types\n      node.type = util.typeCheck(node.left.type, node.right.type);\n      // error\n      if (!node.type) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.operator, node.left.type, node.right.type]);\n      }\n      return node;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      // eval asignment right hand side\n      node.right = __evalNode(node.right);\n      // check if variable exists\n      var varName = node.left.name;\n      var variable = symbolTable.findSymbol(varName);\n      if (!variable) {\n        // eval as variable statement instead\n        return __evalNode(util.constructVarDeclarator(node));\n      }\n      // eval left hand side\n      node.left = __evalNode(node.left);\n\n      // check types\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.right.type, node.left.type]);\n      }\n\n      return node;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      // increase current scope\n      symbolTable.enterScope();\n\n      node.body.forEach(function(item) {\n        item = __evalNode(item);\n      });\n\n      // decrease scope\n      symbolTable.exitScope();\n      \n      return node;\n    },\n\n    PROGRAM: function (node) {\n\n      node.body.forEach(function(item) {\n        item = __evalNode(item);\n      });\n      \n      return node;\n    },\n\n    IF_STATEMENT: function (node) {\n      // parse test condition\n      node.test = __evalNode(node.test);\n      // check test type\n      if (node.test.type !== 'bool') {\n        return errorManager.logError(node, node.test.location, 'not_a_bool');\n      }\n\n      // parse consequent and alternate\n      node.consequent = __evalNode(node.consequent);\n      if (node.alternate) {\n        node.alternate = __evalNode(node.alternate);\n      }\n      return node;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n\n      // check types\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        // error\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.left.type, node.right.type]);\n      }\n      else if (!util.isEqualityOperator(node.operator) && !util.isNumber(cType)) {\n        // cant compare\n        return errorManager.logError(node, node.location, 'not_a_number', [node.operator]);\n      }\n      return node;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      node.argument = __evalNode(node.argument);\n      if (!util.isNumber(node.argument.type)) {\n        // error\n        return errorManager.logError(node, node.location, 'not_a_number');\n      }\n      node.type = node.argument.type; \n      return node;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      node.argument = __evalNode(node.argument);\n      var cType = util.typeCheck(node.argument.type);\n      if (cType !== 'bool') {\n        // error\n        return errorManager.logError(node, node.location, 'not_a_bool');\n      }\n      return node;\n    }\n\n  };\n\n  // :: SPARK EVALUATOR\n  global.SparkEvaluator = api;\n  return api;\n\n})();","module.exports = (function () {\n  // :: CONSTANTS\n  'use strict';\n  \n  var DEFAULT_CONSTANTS = {\n    LOW: {\n      name: 'LOW',\n      type: 'int',\n      value: 0\n    },\n    HIGH: {\n      name: 'HIGH',\n      type: 'int',\n      value: 1\n    },\n    READ: {\n      name: 'READ',\n      type: 'int',\n      value: 0\n    },\n    WRITE: {\n      name: 'WRITE',\n      type: 'int',\n      value: 1\n    }\n  };\n\n  return DEFAULT_CONSTANTS;\n\n})();","module.exports = (function () {\n  // :: ERROR MANAGER\n  'use strict';\n\n  var errorConvertMaps = {\n    operator: {\n      '+' : 'add',\n      '-' : 'subtract',\n      '*' : 'multiply',\n      '/' : 'divide'\n    }\n  };\n\n  var errorMap = {\n    VARIABLE_STATEMENT    : {\n      type_mismatch       :   'variable \"{0}\" does not match type \"{1}\"',\n      already_exists      :   'variable \"{0}\" was already initialized as {1} on line {2}',\n      does_not_exist      :   'variable \"{0}\" is not defined'\n                            },\n    VARIABLE_DECLARATOR   : {\n      already_initialized :   'variable \"{0}\" was already initialized as {1} on line {2}',\n      already_declared    :   'variable \"{0}\" was already declared on line {1}'\n                            },\n    FUNCTION_DECLARATION  : {\n      already_exists      :   'function \"{0}\" was already declared on line {1}'\n                            },\n    PARAM_DECLARATOR      : {\n      duplicate_param     :   'duplicate parameter \"{0}\"'\n                            },\n    RETURN_STATEMENT      : {\n      return_outside      :   'return statement outside function declaration',\n      type_mismatch       :   'return statement type does not match function \"{0}\"'\n                            },\n    IDENTIFIER            : {\n      does_not_exist      :   'variable \"{0}\" does not exist'\n                            },\n    BINARY_EXPRESSION     : {\n      type_mismatch       :   '\"{0}\" operation types do not match, can\\'t {operator: 0} \"{1}\" and \"{2}\"'\n                            },\n    LOGICAL_EXPRESSION    : {\n      type_mismatch       :   'can\\'t compare \"{0}\" and \"{1}\"',\n      cant_compare        :   'can\\'t compare \"{0}\" and \"{1}\"',\n      not_a_number        :   'can use \"{0}\" operator only on numbers'\n                            },\n    ASSIGNMENT_STATEMENT  : {\n      type_mismatch       :   'assignment types mismatch, can\\'t assign \"{0}\" to \"{1}\"'\n                            },\n    UPDATE_EXPRESSION     : {\n      not_a_number        :   'expression is not a number'\n                            },\n    UNARY_EXPRESSION      : {\n      not_a_bool          :   'unary expression must be a boolean'\n                            },\n    IF_STATEMENT          : {\n      not_a_bool          :   'IF condition must be a boolean'\n                            }\n  };\n\n  // log error\n  var logError = function(node, location, errorType, params) {\n    var errorCategory = (typeof node === 'string') ? node : node['$$'];\n    var errorMessage = errorMap[errorCategory][errorType];\n    // 'parse' error message\n    if (params) {\n      for (var i=0,l=params.length; i<l; i++) {\n        var parameter = params[i];\n        var paramRegexA = new RegExp('\\\\{[ ]*([a-z]+)[ ]*\\\\:[ ]*'+ i +'[ ]*\\\\}', 'gi');\n        var paramRegexB = new RegExp('\\\\{[ ]*'+ i +'[ ]*\\\\}', 'gi');\n        errorMessage = errorMessage.replace(paramRegexA, function (a, b) {\n          var cMap = errorConvertMaps[b];\n          console.log('>woo>');\n          console.log(a, b);\n          return cMap[params[i]];\n        });\n        errorMessage = errorMessage.replace(paramRegexB, params[i]);\n      }\n    }\n\n    var err = {\n      error: {\n        location: location,\n        message: errorMessage,\n        node: node\n      }\n    }\n    console.log(err.location);\n    console.log(err.message);\n\n    return err;\n  }\n\n  // api\n  var api = {\n    logError: logError\n  }\n\n\n  // :: EXPORT\n  return api;\n\n})();","module.exports = (function () {\n  // :: UTILS\n  'use strict';\n  var numberTypeScale = ['byte', 'int', 'long', 'float'];\n  var equalityOperatorMap = ['==', '!=', 'is', 'is not'];\n  var signedIntegerLimits = {\n    'byte': 128,\n    'int': 32767,\n    'long': 2147483647\n  };\n  \n  var api = {\n    constructVarDeclarator: function (node) {\n      node['$$'] = 'VARIABLE_STATEMENT';\n      node.type = node.right.type;\n      node.declarations = [\n        {\n          '$$': 'VARIABLE_DECLARATOR',\n          'id': {\n            'location': node.left.location,\n            '$$': 'IDENTIFIER',\n            'name': node.left.name\n          },\n          'location': node.left.location,\n          'init': node.right\n        }\n      ];\n\n      return node;\n    },\n    typeCheck: function (leftType, rightType) {\n      if (!leftType || !rightType) {\n        return false;\n      }\n      // types match - return\n      if (leftType === rightType) {\n        return leftType;\n      }\n\n      // check numbers\n      var iLeft = numberTypeScale.indexOf(leftType);\n      if (iLeft > -1) {\n        var iRight = numberTypeScale.indexOf(rightType);\n        if (iRight > -1) {\n          // promote left type\n          if (iLeft < iRight) {\n            leftType = rightType;\n          }\n          return leftType;\n        }\n        // left is number, right is not\n        return false;\n      }\n\n      return false;\n    },\n    getParameters: function (paramArray) {\n\n    },\n    checkParamDuplicates: function (params) {\n      for (var i=1,l=params.length; i<l; i++) {\n        var curPram = params[i];\n        for (var j=0; j<i; j++) {\n          var prvParam = params[j];\n          if (prvParam.id.name === curPram.id.name) {\n            return curPram;\n          }\n        }\n      }\n      return false;\n    },\n    isNumber: function (type) {\n      return numberTypeScale.indexOf(type) > -1;\n    },\n    isEqualityOperator: function (operator) {\n      return equalityOperatorMap.indexOf(operator) > -1;\n    },\n    getIntegerType: function (number) {\n      var nmb = parseInt(number, 10);\n      var a_nmb = Math.abs(nmb);\n\n      var resType = 'int';\n      var last = signedIntegerLimits['long'];\n\n      for (var nType in signedIntegerLimits) {\n        if (signedIntegerLimits.hasOwnProperty(nType)) {\n          var limit = signedIntegerLimits[nType];\n          if (a_nmb <= limit && last >= limit) {\n            resType = nType;\n            last = limit;\n          }\n        }\n      }\n\n      return resType;\n    }\n  };\n  // :: EXPORT\n  return api;\n\n})();","module.exports = (function () {\n  // :: FUNCTION TABLE\n  'use strict';\n\n  var table = {};\n  var currentFunc = {\n    node: null,\n    returns: []\n  };\n  \n  var api = {\n    getTable: function () {\n      return table;\n    },\n\n    reset: function () {\n      table = {};\n      currentFunc = {\n        node: null,\n        returns: []\n      };\n    },\n\n    getCurrentFunc: function () {\n      return currentFunc;\n    },\n\n    enterFunc: function (node) {\n      currentFunc.node = node;\n    },\n\n    exitFunc: function () {\n      currentFunc = {\n        node: null,\n        returns: []\n      };\n    },\n\n    funcAddReturn: function (node) {\n      current.returns.push(node);\n    },\n\n    getSignature: function (node) {\n      var result = node.type + '__' + node.id.name + '__';\n      for (var i=0, l=node.params.length; i<l; i++) {\n        result += node.params[i].type + '_';\n      }\n      result += 'fn';\n      return result;\n    },\n\n    getParams: function (params) {\n      var result = [];\n      for (var i=0,l=params.length;i<l;i++) {\n        var pr = params[i];\n        result.push({ type: pr.type, name: pr.id.name });\n      }\n      return result;\n    },\n\n    findFunc: function (node) {\n      var signature = api.getSignature(node);\n      if (table.hasOwnProperty(signature)) {\n        return table[signature];\n      }\n      return null;\n    },\n\n    addFunc: function (node) {\n      var signature = api.getSignature(node);\n      var name = node.id.name;\n      var type = node.type;\n      var params = api.getParams(node.params);\n      var initLine = node.location.start.line;\n      var doc = (node.doc) ? node.doc.body : \"\";\n\n      table[signature] = {\n        name: name,\n        type: type,\n        params: params,\n        initLine: initLine,\n        doc: doc\n      };\n    }\n  }\n  // :: EXPORT\n  return api;\n\n})();\n","module.exports = (function () {\n  // :: SYMBOL TABLE\n  'use strict';\n\n  var initialScope = {};\n\n  var scopePointer = 1;\n  var table = {\n    sc0: initialScope,\n    sc1: {}\n  };\n  var currentScope = table['sc' + scopePointer];\n\n  var api = {\n\n    setInitialScope: function (scope) {\n      initialScope = scope;\n      api.reset();\n    },\n\n    getTable: function() {\n      return table;\n    },\n\n    reset: function () {\n      scopePointer = 1;\n      table = {\n        sc0: initialScope,\n        sc1: {}\n      };\n      currentScope = table['sc' + scopePointer];\n    },\n\n    enterScope: function () {\n      scopePointer += 1;\n      table['sc' + scopePointer] = {};\n      currentScope = table['sc' + scopePointer];\n    },\n\n    exitScope: function () {\n      if (scopePointer > 1) {\n        table['sc' + scopePointer] = null;\n      }\n      scopePointer -= 1;\n      currentScope = table['sc' + scopePointer];\n    },\n\n    getScope: function (num) {\n      var scNum = num || scopePointer;\n      return table['sc' + scNum];\n    },\n\n    findSymbol: function (name) {\n      for (var i = scopePointer; i >= 0; i--) {\n        var tempScope = api.getScope(i);\n        if (tempScope.hasOwnProperty(name)) {\n          return tempScope[name];\n        }\n      }\n      return null;\n    },\n\n    addSymbol: function (symbol, it) {\n      var init = it || symbol.init;\n      var name = symbol.id.name;\n      var value = init.value;\n      var type = init.type;\n      var initLine = symbol.location.start.line;\n\n      currentScope[name] = {\n        name: name,\n        value: value,\n        type: type,\n        initLine: initLine\n      };\n    },\n\n    checkScope: function (name) {\n      if (currentScope.hasOwnProperty(name)) {\n        return currentScope[name];\n      } else {\n        return false;\n      }\n    }  \n  }\n\n  // :: EXPORT\n  return api;\n  \n})();"],"sourceRoot":"/source/"}