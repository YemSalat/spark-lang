{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/common/constants.js","evaluator.js","src/common/functions.js","src/evaluator/evaluator.js","src/evaluator/modules/ErrorManager.js","src/evaluator/modules/EvaluatorUtil.js","src/evaluator/modules/FuncTable.js","src/evaluator/modules/SymbolTable.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","api","DEFAULT_CONSTANTS","LOW","name","type","value","HIGH","READ","WRITE",2,"DEFAULT_FUNCTIONS","millis","pinRead","pinWrite","pinMode","print","println",3,"global","SemanticError","message","location","this","symbolTable","funcTable","errorManager","util","__evalNode","node","method","mType","pNode","evaluate","error","console","log","JSON","stringify","parse","tree","options","reset","_tree","symbolScope","getTable","funcScope","DOCSTRING","VARIABLE_STATEMENT","varType","declarations","item","initType","init","cType","typeCheck","logError","id","isNumber","compareNumberTypes","varName","variable","checkScope","initLine","cVal","addSymbol","VARIABLE_DECLARATOR","FUNCTION_DECLARATION","cName","hasOwnProperty","cFunc","findFunc","cParamDupes","checkParamDuplicates","params","addFunc","enterScope","defaultParamReached","enterFunc","body","curFunc","getCurrentFunc","returnAmount","returns","exitFunc","exitScope","PARAM_DECLARATOR","RETURN_STATEMENT","argument","errLocation","funcAddReturn","CALL_STATEMENT","callee","arguments","funcHasDefaults","defParams","slice","push","FOR_STATEMENT","test","update","BREAK_STATEMENT","CONTINUE_STATEMENT","EXPRESSION_STATEMENT","newNode","expression","IDENTIFIER","findSymbol","LITERAL","getIntegerType","BINARY_EXPRESSION","left","right","operator","ASSIGNMENT_STATEMENT","constructVarDeclarator","ASSIGNMENT_ACTION","BLOCK_STATEMENT","forEach","PROGRAM","IF_STATEMENT","consequent","alternate","LOGICAL_EXPRESSION","isEqualityOperator","UPDATE_EXPRESSION","UNARY_EXPRESSION","SparkEvaluator","self","window","./../common/constants","./../common/functions","./modules/ErrorManager","./modules/EvaluatorUtil","./modules/FuncTable","./modules/SymbolTable",4,"errorConvertMaps","+","-","*","/","typeArticle","int","byte","long","float","bool","str","errorMap","type_mismatch","already_exists","does_not_exist","number_doesnt_fit","already_initialized","already_declared","must_return","incorrect_params","cant_redeclare","duplicate_param","return_outside","cant_compare","not_a_number","not_a_bool","errorType","errorCategory","errorMessage","cParam","paramRegexA","RegExp","paramRegexB","replace","b","cMap","err",5,"numberTypeScale","equalityOperatorMap","signedIntegerLimits","$$","leftType","rightType","strict","iLeft","indexOf","iRight","getParameters","paramArray","curPram","j","prvParam","typeA","typeB","nA","nB","Infinity","number","nmb","parseInt","a_nmb","Math","abs","resType","last","nType","limit",6,"table","currentFunc","numberTypes","getSignature","cId","result","reachedDefaultParam","paramType","getParams","pr","default","func","signature","match","tableFunc","sigSplit","split","sigStart","sigRest","ll","sigTmp","join","start","line","doc",7,"initialScope","scopePointer","sc0","sc1","currentScope","setInitialScope","scope","getScope","num","scNum","tempScope","symbol","it","../../common/constants"],"mappings":"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","file":"evaluator.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = (function () {\n  // :: CONSTANTS\n  'use strict';\n  \n  var api = {\n    DEFAULT_CONSTANTS: {\n      LOW: {\n        name: 'LOW',\n        type: 'int',\n        value: 0\n      },\n      HIGH: {\n        name: 'HIGH',\n        type: 'int',\n        value: 1\n      },\n      READ: {\n        name: 'READ',\n        type: 'int',\n        value: 0\n      },\n      WRITE: {\n        name: 'WRITE',\n        type: 'int',\n        value: 1\n      }\n    }\n  };\n\n  return api;\n\n})();","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = (function () {\n  // :: CONSTANTS\n  'use strict';\n  \n  var api = {\n    DEFAULT_CONSTANTS: {\n      LOW: {\n        name: 'LOW',\n        type: 'int',\n        value: 0\n      },\n      HIGH: {\n        name: 'HIGH',\n        type: 'int',\n        value: 1\n      },\n      READ: {\n        name: 'READ',\n        type: 'int',\n        value: 0\n      },\n      WRITE: {\n        name: 'WRITE',\n        type: 'int',\n        value: 1\n      }\n    }\n  };\n\n  return api;\n\n})();\n},{}],2:[function(require,module,exports){\nmodule.exports = (function () {\n  // :: CONSTANTS\n  'use strict';\n  \n  var api = {\n      DEFAULT_FUNCTIONS: {\n      millis: 'millis',\n      pinRead: 'digitalRead',\n      pinWrite: 'digitalWrite',\n      pinMode: 'pinMode',\n      print: 'Serial.print',\n      println: 'Serial.println'\n    }\n  }\n\n  return api;\n\n})();\n},{}],3:[function(require,module,exports){\n(function (global){\nmodule.exports = (function() {\n  'use strict';\n\n  // :: MODULES\n  var symbolTable = require('./modules/SymbolTable')\n  var funcTable = require('./modules/FuncTable');\n  var errorManager = require('./modules/ErrorManager');\n  var util = require('./modules/EvaluatorUtil');\n\n  // :: CONSTANTS\n  var DEFAULT_CONSTANTS = require('./../common/constants').DEFAULT_CONSTANTS;\n  var DEFAULT_FUNCTIONS = require('./../common/functions').DEFAULT_FUNCTIONS;\n\n  // :: ERRORS\n  function SemanticError (name, message, location) {\n    this.name = name;\n    this.message = message;\n    this.location = location;\n  }\n\n  // :: PRIVATE\n  var __evalNode = function(node, method) {\n    var mType = method ||\n                (node !== null) ? node['$$'] : null;\n\n    var pNode = null;\n    if (mType) {\n      pNode = evaluate[mType](node)\n      if (pNode.error) {\n        console.log(JSON.stringify( pNode ));\n        throw new SemanticError('SemanticError', pNode.error.message, pNode.error.location);\n      }\n    }\n    else {\n      console.log('Node evaluation method is not defined for:');\n      console.log(node);\n    }\n\n    return pNode;\n  };\n\n  // :: API\n  var api = {\n    parse: function (tree, options) {\n      // reset tables\n      symbolTable.reset();\n      funcTable.reset();\n\n      var _tree = __evalNode(tree);\n\n      return {\n        tree: _tree,\n        symbolScope: symbolTable.getTable(),\n        funcScope: funcTable.getTable()\n      };\n    }\n  };\n\n  // :: EVALUATOR\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return node;\n    },\n\n    VARIABLE_STATEMENT: function(node) {\n      var varType = node.type;\n\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n\n        // eval right side\n        var initType = null;\n        if (item.init !== null) {\n          item.init = __evalNode(item.init);\n          // check types\n          var cType = util.typeCheck(node.type, item.init.type);\n          if (!cType) {\n            return errorManager.logError(node, node.location, 'type_mismatch', [item.id.name, varType]);\n          }\n          else {\n            if (util.isNumber(node.type)) {\n              if (util.compareNumberTypes(varType, item.init.type) < 0)\n                return errorManager.logError(node, node.location, 'number_doesnt_fit', [item.init.type, varType]);\n            }\n            node.type = cType;\n          }\n          initType = cType;\n        }\n        // set identifier type\n        item.type = initType;\n        // check if variable exists\n        var varName = item.id.name;\n        var variable = symbolTable.checkScope(varName);\n        if (variable) {\n          // error\n          return errorManager.logError(node, item.id.location, 'already_exists', [item.id.name, variable.value, variable.initLine]);\n        }\n        else {\n          // add new variable to current scope\n          var cVal = '{null}';\n          if (item.init) {\n            cVal = '{expression}';\n            if (item.init['$$'] === 'LITERAL') {\n              cVal = item.init.value;\n            }\n          }\n          symbolTable.addSymbol(item, { value: cVal, type: node.type });\n        }\n      }\n\n      return node;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n    FUNCTION_DECLARATION: function (node) {\n      var cName = node.id.name;\n      // dont eval built-in functions\n      if (DEFAULT_FUNCTIONS.hasOwnProperty(cName)) {\n        return errorManager.logError(node, node.location, 'cant_redeclare', [cName]);\n      }\n\n      var cFunc = funcTable.findFunc(node);\n      if (cFunc) {\n        // error\n        return errorManager.logError(node, node.location, 'already_exists', [cName, cFunc.initLine]);\n      }\n\n      // check duplicate params\n      var cParamDupes = util.checkParamDuplicates(node.params);\n      if (cParamDupes) {\n        return errorManager.logError(cParamDupes, cParamDupes.location, 'duplicate_param', [cParamDupes.id.name]);\n      }\n\n      funcTable.addFunc(node);\n\n      // increase current scope\n      symbolTable.enterScope();\n\n      // eval params\n      if (node.params) {\n        var defaultParamReached = false;\n        for (var i=0,l=node.params.length; i<l; i++) {\n          var item = __evalNode(node.params[i]);\n          // make sure that params with defaults are at the end\n          if (item.default) {\n            defaultParamReached = true;\n          }\n          else if (defaultParamReached) {\n            // incorrect syntax for default params\n            return errorManager.logError(node, item.location, 'incorrect_params', [cName, node.type]);\n          }\n          symbolTable.addSymbol(item, { value: null, type: item.type });\n        }\n      }\n\n      // enter function (used for return check)\n      funcTable.enterFunc(node);\n      // parse function body\n      node.body = __evalNode(node.body);\n      // evaluate return statemnts\n      var curFunc = funcTable.getCurrentFunc();\n      var returnAmount = curFunc.returns.length;\n      if (node.type !== 'void' && returnAmount === 0) {\n        return errorManager.logError(node, node.id.location, 'must_return', [cName, node.type]);\n      }\n      // exit function\n      funcTable.exitFunc();\n      // exit scope\n      symbolTable.exitScope();\n\n      return node;\n    },\n    \n    PARAM_DECLARATOR: function (node) {\n      // check default value\n      if (node.default) {\n        node.default = __evalNode(node.default);\n        var cType = util.typeCheck(node.type, node.default.type, false);\n        if (!cType) {\n          return errorManager.logError(node, node.location, 'type_mismatch', [node.id.name, node.type]);\n        }\n      }\n      return node;\n    },\n\n    RETURN_STATEMENT: function (node) {\n      node.argument = __evalNode(node.argument);\n      // set return statement type\n      node.type = (node.argument) ? node.argument.type : 'void';\n\n      // check type matches current function\n      var curFunc = funcTable.getCurrentFunc();\n      if (!curFunc.node) {\n        return errorManager.logError(node, node.location, 'return_outside');\n      }\n      var cType = util.typeCheck(node.type, curFunc.node.type);\n      if (!cType) {\n        var errLocation = ( node.argument ) ? node.argument.location : node.location;\n        return errorManager.logError(node, errLocation, 'type_mismatch', [curFunc.node.id.name, curFunc.node.type]);\n      }\n\n      // add return\n      funcTable.funcAddReturn(node);\n\n      return node;\n    },\n\n    CALL_STATEMENT: function (node) {\n      var cName = node.callee.name;\n      // eval arguments      \n      for (var i=0, l=node.arguments.length; i<l; i++) {\n        var cArg = node.arguments[i] = __evalNode(node.arguments[i]);\n      }\n      // dont eval built-in functions\n      if (DEFAULT_FUNCTIONS.hasOwnProperty(cName)) {\n        return node;\n      }\n      // check if function exists\n      var cFunc = funcTable.findFunc(node);\n      if (!cFunc) {\n        return errorManager.logError(node, node.callee.location, 'does_not_exist', [cName]);\n      }\n      // add missing default params\n      if (funcTable.funcHasDefaults(cFunc) && node.arguments.length < cFunc.params.length) {\n        var defParams = cFunc.params.slice(node.arguments.length);\n        for (var i=0, l=defParams.length; i<l; i++) {\n          node.arguments.push(__evalNode(defParams[i].default));\n        }\n      }\n      // assign call statement type\n      node.type = cFunc.type;\n      return node;\n    },\n\n    FOR_STATEMENT: function (node) {\n      symbolTable.enterScope();\n      node.init = __evalNode(node.init);\n      node.test = __evalNode(node.test);\n      node.update = __evalNode(node.update);\n      node.body = __evalNode(node.body);\n      symbolTable.exitScope();\n\n      return node;\n    },\n\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n    EXPRESSION_STATEMENT: function (node) {\n      var newNode = __evalNode(node.expression);\n      return newNode;\n    },\n\n    IDENTIFIER: function (node) {\n      // check if variable exists\n      var varName = node.name;\n      var variable = symbolTable.findSymbol(varName);\n      if (variable) {\n        // assign node type\n        node.type = variable.type;\n      } else {\n        // error\n        return errorManager.logError(node, node.location, 'does_not_exist', [varName]);\n      }\n\n      return node;\n    },\n\n    LITERAL: function(node) {\n      // convert int type\n      if (node.type === 'int') {\n        node.type = util.getIntegerType(node.value);\n      }\n\n      return node;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      // eval left and right parts first\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n      // assign node type\n      // check types\n      node.type = util.typeCheck(node.left.type, node.right.type);\n      // error\n      if (!node.type) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.operator, node.left.type, node.right.type]);\n      }\n      return node;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      // eval asignment right hand side\n      node.right = __evalNode(node.right);\n      // check if variable exists\n      var varName = node.left.name;\n      var variable = symbolTable.findSymbol(varName);\n      if (!variable) {\n        // eval as variable statement instead\n        return __evalNode(util.constructVarDeclarator(node));\n      }\n      // eval left hand side\n      node.left = __evalNode(node.left);\n\n      // check types\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        return errorManager.logError(node, node.left.location, 'type_mismatch', [node.right.type, node.left.type]);\n      }\n\n      return node;\n    },\n\n    ASSIGNMENT_ACTION: function (node) {\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.right.type, node.left.type]);\n      }\n      return node;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      // increase current scope\n      symbolTable.enterScope();\n\n      node.body.forEach(function(item) {\n        item = __evalNode(item);\n      });\n\n      // decrease scope\n      symbolTable.exitScope();\n\n      return node;\n    },\n\n    PROGRAM: function (node) {\n      // parse each program statement\n      node.body.forEach(function(item) {\n        item = __evalNode(item);\n      });\n\n      return node;\n    },\n\n    IF_STATEMENT: function (node) {\n      // parse test condition\n      node.test = __evalNode(node.test);\n      // check test type\n      if (node.test.type !== 'bool') {\n        return errorManager.logError(node, node.test.location, 'not_a_bool');\n      }\n\n      // parse consequent and alternate\n      node.consequent = __evalNode(node.consequent);\n      if (node.alternate) {\n        node.alternate = __evalNode(node.alternate);\n      }\n      return node;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n\n      // check types\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        // error\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.left.type, node.right.type]);\n      }\n      else if (!util.isEqualityOperator(node.operator) && !util.isNumber(cType)) {\n        // cant compare\n        return errorManager.logError(node, node.location, 'not_a_number', [node.operator]);\n      }\n      return node;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      node.argument = __evalNode(node.argument);\n      if (!util.isNumber(node.argument.type)) {\n        // error\n        return errorManager.logError(node, node.location, 'not_a_number');\n      }\n      node.type = node.argument.type;\n      return node;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      node.argument = __evalNode(node.argument);\n      // check 'not' operator is a boolean\n      if (node.operator === '!' && node.argument.type !== 'bool') {\n        // error\n        return errorManager.logError(node, node.location, 'not_a_bool');\n      }\n      node.type = node.argument.type;\n      return node;\n    }\n\n  };\n\n  // :: EXPORT\n  global.SparkEvaluator = api;\n  return api;\n\n})();\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./../common/constants\":1,\"./../common/functions\":2,\"./modules/ErrorManager\":4,\"./modules/EvaluatorUtil\":5,\"./modules/FuncTable\":6,\"./modules/SymbolTable\":7}],4:[function(require,module,exports){\nmodule.exports = (function () {\n  'use strict';\n\n  var errorConvertMaps = {\n    operator: {\n      '+' : 'add',\n      '-' : 'subtract',\n      '*' : 'multiply',\n      '/' : 'divide'\n    },\n    typeArticle: {\n      'int'   : 'an',\n      'byte'  : 'a',\n      'long'  : 'a',\n      'float' : 'a',\n      'bool'  : 'a',\n      'str'   : 'a'\n    }\n  };\n\n  var errorMap = {\n    VARIABLE_STATEMENT    : {\n      type_mismatch       :   'variable \"{0}\" does not match type \"{1}\"',\n      already_exists      :   'variable \"{0}\" was already initialized as \\'{1}\\' on line {2}',\n      does_not_exist      :   'variable \"{0}\" is not defined',\n      number_doesnt_fit   :   'number of type \"{0}\" won\\'t fit into {typeArticle: 1} \"{1}\"'\n                            },\n    VARIABLE_DECLARATOR   : {\n      already_initialized :   'variable \"{0}\" was already initialized as {1} on line {2}',\n      already_declared    :   'variable \"{0}\" was already declared on line {1}'\n                            },\n    FUNCTION_DECLARATION  : {\n      already_exists      :   'function \"{0}\" was already declared on line {1}',\n      must_return         :   'function \"{0}\" must return {typeArticle: 1} \"{1}\"',\n      incorrect_params    :   'parameters with default values must be declared last',\n      cant_redeclare      :   'can\\'t re-declare built-in function \"{0}\"'\n                            },\n    CALL_STATEMENT        : {\n      does_not_exist      :   'function \"{0}\" does not exist'\n                            },\n    PARAM_DECLARATOR      : {\n      duplicate_param     :   'duplicate parameter \"{0}\"',\n      type_mismatch       :   'default value for parameter \"{0}\" must be {typeArticle: 1} \"{1}\"'\n                            },\n    RETURN_STATEMENT      : {\n      return_outside      :   'return statement outside function declaration',\n      type_mismatch       :   'return statement type does not match function \"{0}\" of type \"{1}\"'\n                            },\n    IDENTIFIER            : {\n      does_not_exist      :   'variable \"{0}\" does not exist'\n                            },\n    BINARY_EXPRESSION     : {\n      type_mismatch       :   '\"{0}\" operation types do not match, can\\'t {operator: 0} \"{1}\" and \"{2}\"'\n                            },\n    LOGICAL_EXPRESSION    : {\n      type_mismatch       :   'can\\'t compare \"{0}\" and \"{1}\"',\n      cant_compare        :   'can\\'t compare \"{0}\" and \"{1}\"',\n      not_a_number        :   'can use \"{0}\" operator only on numbers'\n                            },\n    ASSIGNMENT_STATEMENT  : {\n      type_mismatch       :   'assignment types mismatch, can\\'t assign \"{0}\" to \"{1}\"'\n                            },\n    ASSIGNMENT_ACTION     : {\n      type_mismatch       :   'assignment types mismatch, can\\'t assign \"{0}\" to \"{1}\"'\n                            },\n    UPDATE_EXPRESSION     : {\n      not_a_number        :   'expression is not a number'\n                            },\n    UNARY_EXPRESSION      : {\n      not_a_bool          :   'unary expression must be a boolean'\n                            },\n    IF_STATEMENT          : {\n      not_a_bool          :   'IF condition must be a boolean'\n                            }\n  };\n\n\n  // log error\n  var logError = function(node, location, errorType, params) {\n    var errorCategory = (typeof node === 'string') ? node : node['$$'];\n    var errorMessage = errorMap[errorCategory][errorType];\n    // 'parse' error message\n    if (params) {\n      for (var i=0,l=params.length; i<l; i++) {\n        var cParam = params[i];\n        var paramRegexA = new RegExp('\\\\{[ ]*([a-z]+)[ ]*\\\\:[ ]*'+ i +'[ ]*\\\\}', 'gi');\n        var paramRegexB = new RegExp('\\\\{[ ]*'+ i +'[ ]*\\\\}', 'gi');\n        errorMessage = errorMessage.replace(paramRegexA, function (a, b) {\n          var cMap = errorConvertMaps[b];\n          return cMap[cParam];\n        });\n        errorMessage = errorMessage.replace(paramRegexB, cParam);\n      }\n    }\n\n    var err = {\n      error: {\n        location: location,\n        message: errorMessage,\n        node: node\n      }\n    };\n\n    return err;\n  };\n\n  // api\n  var api = {\n    logError: logError\n  };\n\n\n  // :: EXPORT\n  return api;\n\n})();\n},{}],5:[function(require,module,exports){\nmodule.exports = (function () {\n  'use strict';\n\n  // :: PRIVATE\n  var numberTypeScale = ['byte', 'int', 'long', 'float'];\n  var equalityOperatorMap = ['==', '!=', 'is', 'is not'];\n  var signedIntegerLimits = {\n    'byte': 128,\n    'int': 32767,\n    'long': 2147483647\n  };\n  \n\n  // :: API\n  var api = {\n    constructVarDeclarator: function (node) {\n      node['$$'] = 'VARIABLE_STATEMENT';\n      node.type = node.right.type;\n      node.declarations = [\n        {\n          '$$': 'VARIABLE_DECLARATOR',\n          'id': {\n            'location': node.left.location,\n            '$$': 'IDENTIFIER',\n            'name': node.left.name\n          },\n          'location': node.left.location,\n          'init': node.right\n        }\n      ];\n\n      return node;\n    },\n\n    typeCheck: function (leftType, rightType, strict) {\n      if (strict) {\n        return leftType === rightType;\n      }\n      if (!leftType || !rightType) {\n        return false;\n      }\n      // types match - return\n      if (leftType === rightType) {\n        return leftType;\n      }\n\n      // check numbers\n      var iLeft = numberTypeScale.indexOf(leftType);\n      if (iLeft > -1) {\n        var iRight = numberTypeScale.indexOf(rightType);\n        if (iRight > -1) {\n          // promote left type\n          if (iLeft < iRight) {\n            leftType = rightType;\n          }\n          return leftType;\n        }\n        // left is number, right is not\n        return false;\n      }\n\n      return false;\n    },\n\n    getParameters: function (paramArray) {\n\n    },\n\n    checkParamDuplicates: function (params) {\n      for (var i=1,l=params.length; i<l; i++) {\n        var curPram = params[i];\n        for (var j=0; j<i; j++) {\n          var prvParam = params[j];\n          if (prvParam.id.name === curPram.id.name) {\n            return curPram;\n          }\n        }\n      }\n      return false;\n    },\n\n    isNumber: function (type) {\n      return numberTypeScale.indexOf(type) > -1;\n    },\n\n    compareNumberTypes: function (typeA, typeB) {\n      var nA = numberTypeScale.indexOf(typeA);\n      var nB = numberTypeScale.indexOf(typeB);\n      if (nA > -1 && nB > -1) {\n        return nA - nB;\n      }\n      else {\n        return -Infinity; // something went wrong, check nA/nB\n      }\n    },\n\n    isEqualityOperator: function (operator) {\n      return equalityOperatorMap.indexOf(operator) > -1;\n    },\n\n    getIntegerType: function (number) {\n      var nmb = parseInt(number, 10);\n      var a_nmb = Math.abs(nmb);\n\n      var resType = 'int';\n      var last = signedIntegerLimits['long'];\n\n      for (var nType in signedIntegerLimits) {\n        if (signedIntegerLimits.hasOwnProperty(nType)) {\n          var limit = signedIntegerLimits[nType];\n          if (a_nmb <= limit && last >= limit) {\n            resType = nType;\n            last = limit;\n          }\n        }\n      }\n\n      return resType;\n    }\n  };\n\n  // :: EXPORT\n  return api;\n\n})();\n},{}],6:[function(require,module,exports){\nmodule.exports = (function () {\n  'use strict';\n\n  // :: PRIVATE\n  var table = {};\n  var currentFunc = {\n    node: null,\n    returns: []\n  };\n\n  // @TODO: REFACTOR!  \n  var numberTypes = ['byte', 'int', 'long', 'float'];\n  var isNumber = function (type) {\n    return numberTypes.indexOf(type) > -1;\n  }\n  \n  // :: API\n  var api = {\n    getTable: function () {\n      return table;\n    },\n\n    reset: function () {\n      table = {};\n      currentFunc = {\n        node: null,\n        returns: []\n      };\n    },\n\n    getCurrentFunc: function () {\n      return currentFunc;\n    },\n\n    enterFunc: function (node) {\n      currentFunc.node = node;\n    },\n\n    exitFunc: function () {\n      currentFunc = {\n        node: null,\n        returns: []\n      };\n    },\n\n    funcAddReturn: function (node) {\n      currentFunc.returns.push(node);\n    },\n\n    getSignature: function (node) {\n      var cId = node.id || node.callee;\n      var params = node.params;\n      if (node['$$'] === 'CALL_STATEMENT') {\n        params = node.arguments;\n      } \n      var result = cId.name + '__';\n      var reachedDefaultParam = false;\n      var paramTypes = [];\n      for (var i=0, l=params.length; i<l; i++) {\n        var cParam = params[i];\n        if ( !reachedDefaultParam && cParam.default) {\n          result += '|'; // separate default params with pipes\n          reachedDefaultParam = true;\n        }\n        var paramType = isNumber(cParam.type) ? 'num' : cParam.type;\n        result += paramType + '_';\n      }\n      return result;\n    },\n\n    getParams: function (params) {\n      var result = [];\n      for (var i=0,l=params.length;i<l;i++) {\n        var pr = params[i];\n        result.push({\n          type: pr.type,\n          name: pr.id.name,\n          default: pr.default\n        });\n      }\n      return result;\n    },\n\n    funcHasDefaults: function (func) {\n      return func.signature.match(/\\|/) !== null;\n    },\n\n    findFunc: function (node) {\n      var cId = node.id || node.callee;\n      var name = cId.name;\n      var signature = api.getSignature(node);\n      if (table.hasOwnProperty(name)) {\n        var tableFunc = table[name];\n        for (var i=0, l=tableFunc.length; i<l; i++) {\n          var cFunc = tableFunc[i];\n          if (cFunc.signature === signature) {\n            return cFunc; \n          }\n          else if (api.funcHasDefaults(cFunc)) {\n            // @TODO: REFACTOR!\n            var sigSplit = cFunc.signature.split('|');\n            var sigStart = sigSplit[0]; \n            var sigRest = sigSplit[1].split('_').slice(0, -1);\n            for (var j=0, ll=sigRest.length; j<=ll; j++) {\n              var sigTmp = sigStart + sigRest.slice(0, j).join('_');\n              if (sigTmp[sigTmp.length - 1] !== '_') {\n                sigTmp += '_';\n              }\n              if (sigTmp === signature) {\n                return cFunc;\n              }\n            }\n          }\n        }\n      }\n      return null;\n    },\n\n    addFunc: function (node) {\n      var signature = api.getSignature(node);\n      var name = node.id.name;\n      var type = node.type;\n      var params = api.getParams(node.params);\n      var initLine = node.location.start.line;\n      var doc = (node.doc) ? node.doc.body : \"\";\n\n      if (! table[name] ) {\n        table[name] = [];\n      }\n\n      var func = {\n        signature: signature,\n        type: type,\n        params: params,\n        initLine: initLine,\n        doc: doc,\n        node: node\n      };\n\n      table[name].push(func);\n\n      return func;\n    }\n  }\n\n  // :: EXPORT\n  return api;\n\n})();\n\n},{}],7:[function(require,module,exports){\nmodule.exports = (function () {\n  'use strict';\n\n  // :: MODULES\n  var initialScope = require('../../common/constants').DEFAULT_CONSTANTS;\n\n  // :: PRIVATE\n  var scopePointer = 1;\n  var table = {\n    sc0: initialScope,\n    sc1: {}\n  };\n  var currentScope = table['sc' + scopePointer];\n\n  // :: API\n  var api = {\n\n    setInitialScope: function (scope) {\n      initialScope = scope;\n      api.reset();\n    },\n\n    getTable: function() {\n      return table;\n    },\n\n    reset: function () {\n      scopePointer = 1;\n      table = {\n        sc0: initialScope,\n        sc1: {}\n      };\n      currentScope = table['sc' + scopePointer];\n    },\n\n    enterScope: function () {\n      scopePointer += 1;\n      table['sc' + scopePointer] = {};\n      currentScope = table['sc' + scopePointer];\n    },\n\n    exitScope: function () {\n      if (scopePointer > 1) {\n        table['sc' + scopePointer] = null;\n      }\n      scopePointer -= 1;\n      currentScope = table['sc' + scopePointer];\n    },\n\n    getScope: function (num) {\n      var scNum = (typeof num !== 'udefined') ? num : scopePointer;\n      return table['sc' + scNum];\n    },\n\n    findSymbol: function (name) {\n      for (var i = scopePointer; i >= 0; i--) {\n        var tempScope = api.getScope(i);\n        if (tempScope.hasOwnProperty(name)) {\n          return tempScope[name];\n        }\n      }\n      return null;\n    },\n\n    addSymbol: function (symbol, it) {\n      var init = it || symbol.init;\n      var name = symbol.id.name;\n      var value = init.value;\n      var type = init.type;\n      var initLine = symbol.location.start.line;\n\n      currentScope[name] = {\n        name: name,\n        value: value,\n        type: type,\n        initLine: initLine\n      };\n    },\n\n    checkScope: function (name) {\n      if (currentScope.hasOwnProperty(name)) {\n        return currentScope[name];\n      } else {\n        return false;\n      }\n    }  \n  }\n\n  // :: EXPORT\n  return api;\n  \n})();\n},{\"../../common/constants\":1}]},{},[3])\n\n","module.exports = (function () {\n  // :: CONSTANTS\n  'use strict';\n  \n  var api = {\n      DEFAULT_FUNCTIONS: {\n      millis: 'millis',\n      pinRead: 'digitalRead',\n      pinWrite: 'digitalWrite',\n      pinMode: 'pinMode',\n      print: 'Serial.print',\n      println: 'Serial.println'\n    }\n  }\n\n  return api;\n\n})();","module.exports = (function() {\n  'use strict';\n\n  // :: MODULES\n  var symbolTable = require('./modules/SymbolTable')\n  var funcTable = require('./modules/FuncTable');\n  var errorManager = require('./modules/ErrorManager');\n  var util = require('./modules/EvaluatorUtil');\n\n  // :: CONSTANTS\n  var DEFAULT_CONSTANTS = require('./../common/constants').DEFAULT_CONSTANTS;\n  var DEFAULT_FUNCTIONS = require('./../common/functions').DEFAULT_FUNCTIONS;\n\n  // :: ERRORS\n  function SemanticError (name, message, location) {\n    this.name = name;\n    this.message = message;\n    this.location = location;\n  }\n\n  // :: PRIVATE\n  var __evalNode = function(node, method) {\n    var mType = method ||\n                (node !== null) ? node['$$'] : null;\n\n    var pNode = null;\n    if (mType) {\n      pNode = evaluate[mType](node)\n      if (pNode.error) {\n        console.log(JSON.stringify( pNode ));\n        throw new SemanticError('SemanticError', pNode.error.message, pNode.error.location);\n      }\n    }\n    else {\n      console.log('Node evaluation method is not defined for:');\n      console.log(node);\n    }\n\n    return pNode;\n  };\n\n  // :: API\n  var api = {\n    parse: function (tree, options) {\n      // reset tables\n      symbolTable.reset();\n      funcTable.reset();\n\n      var _tree = __evalNode(tree);\n\n      return {\n        tree: _tree,\n        symbolScope: symbolTable.getTable(),\n        funcScope: funcTable.getTable()\n      };\n    }\n  };\n\n  // :: EVALUATOR\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return node;\n    },\n\n    VARIABLE_STATEMENT: function(node) {\n      var varType = node.type;\n\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n\n        // eval right side\n        var initType = null;\n        if (item.init !== null) {\n          item.init = __evalNode(item.init);\n          // check types\n          var cType = util.typeCheck(node.type, item.init.type);\n          if (!cType) {\n            return errorManager.logError(node, node.location, 'type_mismatch', [item.id.name, varType]);\n          }\n          else {\n            if (util.isNumber(node.type)) {\n              if (util.compareNumberTypes(varType, item.init.type) < 0)\n                return errorManager.logError(node, node.location, 'number_doesnt_fit', [item.init.type, varType]);\n            }\n            node.type = cType;\n          }\n          initType = cType;\n        }\n        // set identifier type\n        item.type = initType;\n        // check if variable exists\n        var varName = item.id.name;\n        var variable = symbolTable.checkScope(varName);\n        if (variable) {\n          // error\n          return errorManager.logError(node, item.id.location, 'already_exists', [item.id.name, variable.value, variable.initLine]);\n        }\n        else {\n          // add new variable to current scope\n          var cVal = '{null}';\n          if (item.init) {\n            cVal = '{expression}';\n            if (item.init['$$'] === 'LITERAL') {\n              cVal = item.init.value;\n            }\n          }\n          symbolTable.addSymbol(item, { value: cVal, type: node.type });\n        }\n      }\n\n      return node;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n    FUNCTION_DECLARATION: function (node) {\n      var cName = node.id.name;\n      // dont eval built-in functions\n      if (DEFAULT_FUNCTIONS.hasOwnProperty(cName)) {\n        return errorManager.logError(node, node.location, 'cant_redeclare', [cName]);\n      }\n\n      var cFunc = funcTable.findFunc(node);\n      if (cFunc) {\n        // error\n        return errorManager.logError(node, node.location, 'already_exists', [cName, cFunc.initLine]);\n      }\n\n      // check duplicate params\n      var cParamDupes = util.checkParamDuplicates(node.params);\n      if (cParamDupes) {\n        return errorManager.logError(cParamDupes, cParamDupes.location, 'duplicate_param', [cParamDupes.id.name]);\n      }\n\n      funcTable.addFunc(node);\n\n      // increase current scope\n      symbolTable.enterScope();\n\n      // eval params\n      if (node.params) {\n        var defaultParamReached = false;\n        for (var i=0,l=node.params.length; i<l; i++) {\n          var item = __evalNode(node.params[i]);\n          // make sure that params with defaults are at the end\n          if (item.default) {\n            defaultParamReached = true;\n          }\n          else if (defaultParamReached) {\n            // incorrect syntax for default params\n            return errorManager.logError(node, item.location, 'incorrect_params', [cName, node.type]);\n          }\n          symbolTable.addSymbol(item, { value: null, type: item.type });\n        }\n      }\n\n      // enter function (used for return check)\n      funcTable.enterFunc(node);\n      // parse function body\n      node.body = __evalNode(node.body);\n      // evaluate return statemnts\n      var curFunc = funcTable.getCurrentFunc();\n      var returnAmount = curFunc.returns.length;\n      if (node.type !== 'void' && returnAmount === 0) {\n        return errorManager.logError(node, node.id.location, 'must_return', [cName, node.type]);\n      }\n      // exit function\n      funcTable.exitFunc();\n      // exit scope\n      symbolTable.exitScope();\n\n      return node;\n    },\n    \n    PARAM_DECLARATOR: function (node) {\n      // check default value\n      if (node.default) {\n        node.default = __evalNode(node.default);\n        var cType = util.typeCheck(node.type, node.default.type, false);\n        if (!cType) {\n          return errorManager.logError(node, node.location, 'type_mismatch', [node.id.name, node.type]);\n        }\n      }\n      return node;\n    },\n\n    RETURN_STATEMENT: function (node) {\n      node.argument = __evalNode(node.argument);\n      // set return statement type\n      node.type = (node.argument) ? node.argument.type : 'void';\n\n      // check type matches current function\n      var curFunc = funcTable.getCurrentFunc();\n      if (!curFunc.node) {\n        return errorManager.logError(node, node.location, 'return_outside');\n      }\n      var cType = util.typeCheck(node.type, curFunc.node.type);\n      if (!cType) {\n        var errLocation = ( node.argument ) ? node.argument.location : node.location;\n        return errorManager.logError(node, errLocation, 'type_mismatch', [curFunc.node.id.name, curFunc.node.type]);\n      }\n\n      // add return\n      funcTable.funcAddReturn(node);\n\n      return node;\n    },\n\n    CALL_STATEMENT: function (node) {\n      var cName = node.callee.name;\n      // eval arguments      \n      for (var i=0, l=node.arguments.length; i<l; i++) {\n        var cArg = node.arguments[i] = __evalNode(node.arguments[i]);\n      }\n      // dont eval built-in functions\n      if (DEFAULT_FUNCTIONS.hasOwnProperty(cName)) {\n        return node;\n      }\n      // check if function exists\n      var cFunc = funcTable.findFunc(node);\n      if (!cFunc) {\n        return errorManager.logError(node, node.callee.location, 'does_not_exist', [cName]);\n      }\n      // add missing default params\n      if (funcTable.funcHasDefaults(cFunc) && node.arguments.length < cFunc.params.length) {\n        var defParams = cFunc.params.slice(node.arguments.length);\n        for (var i=0, l=defParams.length; i<l; i++) {\n          node.arguments.push(__evalNode(defParams[i].default));\n        }\n      }\n      // assign call statement type\n      node.type = cFunc.type;\n      return node;\n    },\n\n    FOR_STATEMENT: function (node) {\n      symbolTable.enterScope();\n      node.init = __evalNode(node.init);\n      node.test = __evalNode(node.test);\n      node.update = __evalNode(node.update);\n      node.body = __evalNode(node.body);\n      symbolTable.exitScope();\n\n      return node;\n    },\n\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n    EXPRESSION_STATEMENT: function (node) {\n      var newNode = __evalNode(node.expression);\n      return newNode;\n    },\n\n    IDENTIFIER: function (node) {\n      // check if variable exists\n      var varName = node.name;\n      var variable = symbolTable.findSymbol(varName);\n      if (variable) {\n        // assign node type\n        node.type = variable.type;\n      } else {\n        // error\n        return errorManager.logError(node, node.location, 'does_not_exist', [varName]);\n      }\n\n      return node;\n    },\n\n    LITERAL: function(node) {\n      // convert int type\n      if (node.type === 'int') {\n        node.type = util.getIntegerType(node.value);\n      }\n\n      return node;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      // eval left and right parts first\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n      // assign node type\n      // check types\n      node.type = util.typeCheck(node.left.type, node.right.type);\n      // error\n      if (!node.type) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.operator, node.left.type, node.right.type]);\n      }\n      return node;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      // eval asignment right hand side\n      node.right = __evalNode(node.right);\n      // check if variable exists\n      var varName = node.left.name;\n      var variable = symbolTable.findSymbol(varName);\n      if (!variable) {\n        // eval as variable statement instead\n        return __evalNode(util.constructVarDeclarator(node));\n      }\n      // eval left hand side\n      node.left = __evalNode(node.left);\n\n      // check types\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        return errorManager.logError(node, node.left.location, 'type_mismatch', [node.right.type, node.left.type]);\n      }\n\n      return node;\n    },\n\n    ASSIGNMENT_ACTION: function (node) {\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.right.type, node.left.type]);\n      }\n      return node;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      // increase current scope\n      symbolTable.enterScope();\n\n      node.body.forEach(function(item) {\n        item = __evalNode(item);\n      });\n\n      // decrease scope\n      symbolTable.exitScope();\n\n      return node;\n    },\n\n    PROGRAM: function (node) {\n      // parse each program statement\n      node.body.forEach(function(item) {\n        item = __evalNode(item);\n      });\n\n      return node;\n    },\n\n    IF_STATEMENT: function (node) {\n      // parse test condition\n      node.test = __evalNode(node.test);\n      // check test type\n      if (node.test.type !== 'bool') {\n        return errorManager.logError(node, node.test.location, 'not_a_bool');\n      }\n\n      // parse consequent and alternate\n      node.consequent = __evalNode(node.consequent);\n      if (node.alternate) {\n        node.alternate = __evalNode(node.alternate);\n      }\n      return node;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      node.left = __evalNode(node.left);\n      node.right = __evalNode(node.right);\n\n      // check types\n      var cType = util.typeCheck(node.left.type, node.right.type);\n      if (!cType) {\n        // error\n        return errorManager.logError(node, node.location, 'type_mismatch', [node.left.type, node.right.type]);\n      }\n      else if (!util.isEqualityOperator(node.operator) && !util.isNumber(cType)) {\n        // cant compare\n        return errorManager.logError(node, node.location, 'not_a_number', [node.operator]);\n      }\n      return node;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      node.argument = __evalNode(node.argument);\n      if (!util.isNumber(node.argument.type)) {\n        // error\n        return errorManager.logError(node, node.location, 'not_a_number');\n      }\n      node.type = node.argument.type;\n      return node;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      node.argument = __evalNode(node.argument);\n      // check 'not' operator is a boolean\n      if (node.operator === '!' && node.argument.type !== 'bool') {\n        // error\n        return errorManager.logError(node, node.location, 'not_a_bool');\n      }\n      node.type = node.argument.type;\n      return node;\n    }\n\n  };\n\n  // :: EXPORT\n  global.SparkEvaluator = api;\n  return api;\n\n})();\n","module.exports = (function () {\n  'use strict';\n\n  var errorConvertMaps = {\n    operator: {\n      '+' : 'add',\n      '-' : 'subtract',\n      '*' : 'multiply',\n      '/' : 'divide'\n    },\n    typeArticle: {\n      'int'   : 'an',\n      'byte'  : 'a',\n      'long'  : 'a',\n      'float' : 'a',\n      'bool'  : 'a',\n      'str'   : 'a'\n    }\n  };\n\n  var errorMap = {\n    VARIABLE_STATEMENT    : {\n      type_mismatch       :   'variable \"{0}\" does not match type \"{1}\"',\n      already_exists      :   'variable \"{0}\" was already initialized as \\'{1}\\' on line {2}',\n      does_not_exist      :   'variable \"{0}\" is not defined',\n      number_doesnt_fit   :   'number of type \"{0}\" won\\'t fit into {typeArticle: 1} \"{1}\"'\n                            },\n    VARIABLE_DECLARATOR   : {\n      already_initialized :   'variable \"{0}\" was already initialized as {1} on line {2}',\n      already_declared    :   'variable \"{0}\" was already declared on line {1}'\n                            },\n    FUNCTION_DECLARATION  : {\n      already_exists      :   'function \"{0}\" was already declared on line {1}',\n      must_return         :   'function \"{0}\" must return {typeArticle: 1} \"{1}\"',\n      incorrect_params    :   'parameters with default values must be declared last',\n      cant_redeclare      :   'can\\'t re-declare built-in function \"{0}\"'\n                            },\n    CALL_STATEMENT        : {\n      does_not_exist      :   'function \"{0}\" does not exist'\n                            },\n    PARAM_DECLARATOR      : {\n      duplicate_param     :   'duplicate parameter \"{0}\"',\n      type_mismatch       :   'default value for parameter \"{0}\" must be {typeArticle: 1} \"{1}\"'\n                            },\n    RETURN_STATEMENT      : {\n      return_outside      :   'return statement outside function declaration',\n      type_mismatch       :   'return statement type does not match function \"{0}\" of type \"{1}\"'\n                            },\n    IDENTIFIER            : {\n      does_not_exist      :   'variable \"{0}\" does not exist'\n                            },\n    BINARY_EXPRESSION     : {\n      type_mismatch       :   '\"{0}\" operation types do not match, can\\'t {operator: 0} \"{1}\" and \"{2}\"'\n                            },\n    LOGICAL_EXPRESSION    : {\n      type_mismatch       :   'can\\'t compare \"{0}\" and \"{1}\"',\n      cant_compare        :   'can\\'t compare \"{0}\" and \"{1}\"',\n      not_a_number        :   'can use \"{0}\" operator only on numbers'\n                            },\n    ASSIGNMENT_STATEMENT  : {\n      type_mismatch       :   'assignment types mismatch, can\\'t assign \"{0}\" to \"{1}\"'\n                            },\n    ASSIGNMENT_ACTION     : {\n      type_mismatch       :   'assignment types mismatch, can\\'t assign \"{0}\" to \"{1}\"'\n                            },\n    UPDATE_EXPRESSION     : {\n      not_a_number        :   'expression is not a number'\n                            },\n    UNARY_EXPRESSION      : {\n      not_a_bool          :   'unary expression must be a boolean'\n                            },\n    IF_STATEMENT          : {\n      not_a_bool          :   'IF condition must be a boolean'\n                            }\n  };\n\n\n  // log error\n  var logError = function(node, location, errorType, params) {\n    var errorCategory = (typeof node === 'string') ? node : node['$$'];\n    var errorMessage = errorMap[errorCategory][errorType];\n    // 'parse' error message\n    if (params) {\n      for (var i=0,l=params.length; i<l; i++) {\n        var cParam = params[i];\n        var paramRegexA = new RegExp('\\\\{[ ]*([a-z]+)[ ]*\\\\:[ ]*'+ i +'[ ]*\\\\}', 'gi');\n        var paramRegexB = new RegExp('\\\\{[ ]*'+ i +'[ ]*\\\\}', 'gi');\n        errorMessage = errorMessage.replace(paramRegexA, function (a, b) {\n          var cMap = errorConvertMaps[b];\n          return cMap[cParam];\n        });\n        errorMessage = errorMessage.replace(paramRegexB, cParam);\n      }\n    }\n\n    var err = {\n      error: {\n        location: location,\n        message: errorMessage,\n        node: node\n      }\n    };\n\n    return err;\n  };\n\n  // api\n  var api = {\n    logError: logError\n  };\n\n\n  // :: EXPORT\n  return api;\n\n})();","module.exports = (function () {\n  'use strict';\n\n  // :: PRIVATE\n  var numberTypeScale = ['byte', 'int', 'long', 'float'];\n  var equalityOperatorMap = ['==', '!=', 'is', 'is not'];\n  var signedIntegerLimits = {\n    'byte': 128,\n    'int': 32767,\n    'long': 2147483647\n  };\n  \n\n  // :: API\n  var api = {\n    constructVarDeclarator: function (node) {\n      node['$$'] = 'VARIABLE_STATEMENT';\n      node.type = node.right.type;\n      node.declarations = [\n        {\n          '$$': 'VARIABLE_DECLARATOR',\n          'id': {\n            'location': node.left.location,\n            '$$': 'IDENTIFIER',\n            'name': node.left.name\n          },\n          'location': node.left.location,\n          'init': node.right\n        }\n      ];\n\n      return node;\n    },\n\n    typeCheck: function (leftType, rightType, strict) {\n      if (strict) {\n        return leftType === rightType;\n      }\n      if (!leftType || !rightType) {\n        return false;\n      }\n      // types match - return\n      if (leftType === rightType) {\n        return leftType;\n      }\n\n      // check numbers\n      var iLeft = numberTypeScale.indexOf(leftType);\n      if (iLeft > -1) {\n        var iRight = numberTypeScale.indexOf(rightType);\n        if (iRight > -1) {\n          // promote left type\n          if (iLeft < iRight) {\n            leftType = rightType;\n          }\n          return leftType;\n        }\n        // left is number, right is not\n        return false;\n      }\n\n      return false;\n    },\n\n    getParameters: function (paramArray) {\n\n    },\n\n    checkParamDuplicates: function (params) {\n      for (var i=1,l=params.length; i<l; i++) {\n        var curPram = params[i];\n        for (var j=0; j<i; j++) {\n          var prvParam = params[j];\n          if (prvParam.id.name === curPram.id.name) {\n            return curPram;\n          }\n        }\n      }\n      return false;\n    },\n\n    isNumber: function (type) {\n      return numberTypeScale.indexOf(type) > -1;\n    },\n\n    compareNumberTypes: function (typeA, typeB) {\n      var nA = numberTypeScale.indexOf(typeA);\n      var nB = numberTypeScale.indexOf(typeB);\n      if (nA > -1 && nB > -1) {\n        return nA - nB;\n      }\n      else {\n        return -Infinity; // something went wrong, check nA/nB\n      }\n    },\n\n    isEqualityOperator: function (operator) {\n      return equalityOperatorMap.indexOf(operator) > -1;\n    },\n\n    getIntegerType: function (number) {\n      var nmb = parseInt(number, 10);\n      var a_nmb = Math.abs(nmb);\n\n      var resType = 'int';\n      var last = signedIntegerLimits['long'];\n\n      for (var nType in signedIntegerLimits) {\n        if (signedIntegerLimits.hasOwnProperty(nType)) {\n          var limit = signedIntegerLimits[nType];\n          if (a_nmb <= limit && last >= limit) {\n            resType = nType;\n            last = limit;\n          }\n        }\n      }\n\n      return resType;\n    }\n  };\n\n  // :: EXPORT\n  return api;\n\n})();","module.exports = (function () {\n  'use strict';\n\n  // :: PRIVATE\n  var table = {};\n  var currentFunc = {\n    node: null,\n    returns: []\n  };\n\n  // @TODO: REFACTOR!  \n  var numberTypes = ['byte', 'int', 'long', 'float'];\n  var isNumber = function (type) {\n    return numberTypes.indexOf(type) > -1;\n  }\n  \n  // :: API\n  var api = {\n    getTable: function () {\n      return table;\n    },\n\n    reset: function () {\n      table = {};\n      currentFunc = {\n        node: null,\n        returns: []\n      };\n    },\n\n    getCurrentFunc: function () {\n      return currentFunc;\n    },\n\n    enterFunc: function (node) {\n      currentFunc.node = node;\n    },\n\n    exitFunc: function () {\n      currentFunc = {\n        node: null,\n        returns: []\n      };\n    },\n\n    funcAddReturn: function (node) {\n      currentFunc.returns.push(node);\n    },\n\n    getSignature: function (node) {\n      var cId = node.id || node.callee;\n      var params = node.params;\n      if (node['$$'] === 'CALL_STATEMENT') {\n        params = node.arguments;\n      } \n      var result = cId.name + '__';\n      var reachedDefaultParam = false;\n      var paramTypes = [];\n      for (var i=0, l=params.length; i<l; i++) {\n        var cParam = params[i];\n        if ( !reachedDefaultParam && cParam.default) {\n          result += '|'; // separate default params with pipes\n          reachedDefaultParam = true;\n        }\n        var paramType = isNumber(cParam.type) ? 'num' : cParam.type;\n        result += paramType + '_';\n      }\n      return result;\n    },\n\n    getParams: function (params) {\n      var result = [];\n      for (var i=0,l=params.length;i<l;i++) {\n        var pr = params[i];\n        result.push({\n          type: pr.type,\n          name: pr.id.name,\n          default: pr.default\n        });\n      }\n      return result;\n    },\n\n    funcHasDefaults: function (func) {\n      return func.signature.match(/\\|/) !== null;\n    },\n\n    findFunc: function (node) {\n      var cId = node.id || node.callee;\n      var name = cId.name;\n      var signature = api.getSignature(node);\n      if (table.hasOwnProperty(name)) {\n        var tableFunc = table[name];\n        for (var i=0, l=tableFunc.length; i<l; i++) {\n          var cFunc = tableFunc[i];\n          if (cFunc.signature === signature) {\n            return cFunc; \n          }\n          else if (api.funcHasDefaults(cFunc)) {\n            // @TODO: REFACTOR!\n            var sigSplit = cFunc.signature.split('|');\n            var sigStart = sigSplit[0]; \n            var sigRest = sigSplit[1].split('_').slice(0, -1);\n            for (var j=0, ll=sigRest.length; j<=ll; j++) {\n              var sigTmp = sigStart + sigRest.slice(0, j).join('_');\n              if (sigTmp[sigTmp.length - 1] !== '_') {\n                sigTmp += '_';\n              }\n              if (sigTmp === signature) {\n                return cFunc;\n              }\n            }\n          }\n        }\n      }\n      return null;\n    },\n\n    addFunc: function (node) {\n      var signature = api.getSignature(node);\n      var name = node.id.name;\n      var type = node.type;\n      var params = api.getParams(node.params);\n      var initLine = node.location.start.line;\n      var doc = (node.doc) ? node.doc.body : \"\";\n\n      if (! table[name] ) {\n        table[name] = [];\n      }\n\n      var func = {\n        signature: signature,\n        type: type,\n        params: params,\n        initLine: initLine,\n        doc: doc,\n        node: node\n      };\n\n      table[name].push(func);\n\n      return func;\n    }\n  }\n\n  // :: EXPORT\n  return api;\n\n})();\n","module.exports = (function () {\n  'use strict';\n\n  // :: MODULES\n  var initialScope = require('../../common/constants').DEFAULT_CONSTANTS;\n\n  // :: PRIVATE\n  var scopePointer = 1;\n  var table = {\n    sc0: initialScope,\n    sc1: {}\n  };\n  var currentScope = table['sc' + scopePointer];\n\n  // :: API\n  var api = {\n\n    setInitialScope: function (scope) {\n      initialScope = scope;\n      api.reset();\n    },\n\n    getTable: function() {\n      return table;\n    },\n\n    reset: function () {\n      scopePointer = 1;\n      table = {\n        sc0: initialScope,\n        sc1: {}\n      };\n      currentScope = table['sc' + scopePointer];\n    },\n\n    enterScope: function () {\n      scopePointer += 1;\n      table['sc' + scopePointer] = {};\n      currentScope = table['sc' + scopePointer];\n    },\n\n    exitScope: function () {\n      if (scopePointer > 1) {\n        table['sc' + scopePointer] = null;\n      }\n      scopePointer -= 1;\n      currentScope = table['sc' + scopePointer];\n    },\n\n    getScope: function (num) {\n      var scNum = (typeof num !== 'udefined') ? num : scopePointer;\n      return table['sc' + scNum];\n    },\n\n    findSymbol: function (name) {\n      for (var i = scopePointer; i >= 0; i--) {\n        var tempScope = api.getScope(i);\n        if (tempScope.hasOwnProperty(name)) {\n          return tempScope[name];\n        }\n      }\n      return null;\n    },\n\n    addSymbol: function (symbol, it) {\n      var init = it || symbol.init;\n      var name = symbol.id.name;\n      var value = init.value;\n      var type = init.type;\n      var initLine = symbol.location.start.line;\n\n      currentScope[name] = {\n        name: name,\n        value: value,\n        type: type,\n        initLine: initLine\n      };\n    },\n\n    checkScope: function (name) {\n      if (currentScope.hasOwnProperty(name)) {\n        return currentScope[name];\n      } else {\n        return false;\n      }\n    }  \n  }\n\n  // :: EXPORT\n  return api;\n  \n})();"],"sourceRoot":"/source/"}