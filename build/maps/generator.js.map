{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/generator/generator.js","generator.js","src/generator/modules/GeneratorUtil.js","src/generator/modules/IndentManager.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","indentManager","util","__generateNode","node","method","mType","pNode","evaluate","error","CompilerError","message","location","DOCSTRING","body","join","VARIABLE_STATEMENT","result","generateType","type","declarations","item","varPostfix","id","init","VARIABLE_DECLARATOR","FUNCTION_DECLARATION","doc","name","fnParams","params","prm","push","PARAM_DECLARATOR","RETURN_STATEMENT","argument","CALL_STATEMENT","FOR_STATEMENT","FOR_STATEMENT_DECLARATION","BREAK_STATEMENT","CONTINUE_STATEMENT","EXPRESSION_STATEMENT","expression","IDENTIFIER","LITERAL","value","BINARY_EXPRESSION","left","right","typeCheck","__logError","operator","ASSIGNMENT_STATEMENT","BLOCK_STATEMENT","increase","forEach","getCurrentIndent","decrease","PROGRAM","match","IF_STATEMENT","test","consequent","alternate","LOGICAL_EXPRESSION","UPDATE_EXPRESSION","isNumber","UNARY_EXPRESSION","cType","parse","tree","console","log","trim","this","./modules/GeneratorUtil","./modules/IndentManager",2,"typeMap","byte","ubyte","int","uint","long","ulong","float","str","void","api","GeneratorUtil",3,"indentLevel","indentChar","currentIndent","Array","IndentManager"],"mappings":"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","file":"generator.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var theGenerator = (function(module) {\n  'use strict';\n\n  // :: MODULES\n  var indentManager = require('./modules/IndentManager');\n  var util = require('./modules/GeneratorUtil');\n\n  // :: OP\n  var __generateNode = function(node, method) {\n    var mType = method || node['$$'];\n    var pNode = evaluate[mType](node)\n    if (pNode.error) {\n      throw new CompilerError('SemanticError', pNode.error.message, pNode.error.location);\n    }\n    return pNode;\n  };\n\n  // :: GENERATE\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return '// ' + node.body.join('\\n// ') + '\\n';\n    },\n    \n    VARIABLE_STATEMENT: function(node) {\n      var result = util.generateType(node.type) + ' ';\n\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n        \n        var varPostfix = '';\n        result += __generateNode(item.id) + varPostfix;\n\n        if (item.init) {\n          if (item.init.type === 'str') {\n            varPostfix = '[]';\n          }\n\n          result += ' = ' + __generateNode(item.init);\n        }\n      }\n\n      return result;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n\n    FUNCTION_DECLARATION: function (node) {\n      var result = ''\n      if (node.doc) {\n        result += __generateNode(node.doc);\n      }\n\n      result += node.type + ' ' + node.id.name + ' ( ';\n\n      var fnParams = [];\n      for (var i=0, l=node.params.length; i<l; i++) {\n        var prm = __generateNode(node.params[i]);\n        fnParams.push(prm);\n      }\n\n      result += fnParams.join(', ');\n\n      result += ' ) '\n\n      // parse function body\n      result += __generateNode(node.body);\n      \n      return result;\n    },\n    PARAM_DECLARATOR: function (node) {\n      var result = util.generateType(node.type) + ' ' + node.id.name;\n      return result;\n    },\n    RETURN_STATEMENT: function (node) {\n      var result = 'return ' + __generateNode(node.argument);\n      return result;\n    },\n    CALL_STATEMENT: function (node) {\n      var result = node.name;\n      return result;\n    },\n\n\n\n    FOR_STATEMENT: function (node) {\n      return node;\n    },\n\n    FOR_STATEMENT_DECLARATION: function (node) {\n      return node;\n    },\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n\n    EXPRESSION_STATEMENT: function (node) {\n      var result = __generateNode(node.expression);\n      return result;\n    },\n\n    IDENTIFIER: function (node) {\n      return node.name;\n    },\n\n    LITERAL: function(node) {\n      var result = node.value;\n      if (node.type === 'str') {\n        result = '\"' + result + '\"';\n      }\n      return result;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      // eval left and right parts first\n      node.left = __generateNode(node.left);\n      node.right = __generateNode(node.right);\n      // assign node type\n      // check types\n      node.type = util.typeCheck(node.left, node.right);\n      // error\n      if (!node.type) {\n        return __logError(node, node.location, 'type_mismatch', [node.operator, node.left.type, node.right.type]);\n      }\n      return node;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      var result = __generateNode(node.left);\n      // eval asignment right hand side\n      result += ' = ' + __generateNode(node.right);\n      return result;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      var result = ' {\\n';\n\n      indentManager.increase();\n\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item) + ';\\n';\n      });\n\n      indentManager.decrease();\n      \n      result += '}\\n';\n\n      return result;\n    },\n\n    PROGRAM: function (node) {\n      var result = '';\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item);\n        if (!result.match(/\\}\\n$/)) {\n          result += ';';\n        }\n        result += '\\n';\n      });\n      \n      return result;\n    },\n\n    IF_STATEMENT: function (node) {\n\n      var result = ' if ( ';\n\n      result += __generateNode(node.test);\n\n      result += ' ) ';\n      \n      result += __generateNode(node.consequent);\n\n      if (node.alternate) {\n      result += ' else ';\n        result += __generateNode(node.alternate);\n      }\n      return result;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      node.left = __generateNode(node.left);\n      node.right = __generateNode(node.right);\n\n      var result = node.left + ' ' + node.operator + ' ' + node.right;\n      return result;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      node.argument = __generateNode(node.argument);\n      if (!util.isNumber(node.argument.type)) {\n        // error\n        return __logError(node, node.location, 'not_a_number');\n      }\n      node.type = node.argument.type; \n      return node;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      node.argument = __generateNode(node.argument);\n      var cType = util.typeCheck(node.argument);\n      if (cType !== 'bool') {\n        // error\n        return __logError(node, node.location, 'not_a_bool');\n      }\n      return node;\n    }\n\n  };\n\n  // :: SPARK EVALUATOR\n\n  return {\n    parse: function (tree) {\n      console.log('tree 2:')\n      console.log(tree)\n\n      var code = __generateNode(tree);\n      return code.trim();\n    }\n  };\n\n})(this);","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar theGenerator = (function(module) {\n  'use strict';\n\n  // :: MODULES\n  var indentManager = require('./modules/IndentManager');\n  var util = require('./modules/GeneratorUtil');\n\n  // :: OP\n  var __generateNode = function(node, method) {\n    var mType = method || node['$$'];\n    var pNode = evaluate[mType](node)\n    if (pNode.error) {\n      throw new CompilerError('SemanticError', pNode.error.message, pNode.error.location);\n    }\n    return pNode;\n  };\n\n  // :: GENERATE\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return '// ' + node.body.join('\\n// ') + '\\n';\n    },\n    \n    VARIABLE_STATEMENT: function(node) {\n      var result = util.generateType(node.type) + ' ';\n\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n        \n        var varPostfix = '';\n        result += __generateNode(item.id) + varPostfix;\n\n        if (item.init) {\n          if (item.init.type === 'str') {\n            varPostfix = '[]';\n          }\n\n          result += ' = ' + __generateNode(item.init);\n        }\n      }\n\n      return result;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n\n    FUNCTION_DECLARATION: function (node) {\n      var result = ''\n      if (node.doc) {\n        result += __generateNode(node.doc);\n      }\n\n      result += node.type + ' ' + node.id.name + ' ( ';\n\n      var fnParams = [];\n      for (var i=0, l=node.params.length; i<l; i++) {\n        var prm = __generateNode(node.params[i]);\n        fnParams.push(prm);\n      }\n\n      result += fnParams.join(', ');\n\n      result += ' ) '\n\n      // parse function body\n      result += __generateNode(node.body);\n      \n      return result;\n    },\n    PARAM_DECLARATOR: function (node) {\n      var result = util.generateType(node.type) + ' ' + node.id.name;\n      return result;\n    },\n    RETURN_STATEMENT: function (node) {\n      var result = 'return ' + __generateNode(node.argument);\n      return result;\n    },\n    CALL_STATEMENT: function (node) {\n      var result = node.name;\n      return result;\n    },\n\n\n\n    FOR_STATEMENT: function (node) {\n      return node;\n    },\n\n    FOR_STATEMENT_DECLARATION: function (node) {\n      return node;\n    },\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n\n    EXPRESSION_STATEMENT: function (node) {\n      var result = __generateNode(node.expression);\n      return result;\n    },\n\n    IDENTIFIER: function (node) {\n      return node.name;\n    },\n\n    LITERAL: function(node) {\n      var result = node.value;\n      if (node.type === 'str') {\n        result = '\"' + result + '\"';\n      }\n      return result;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      // eval left and right parts first\n      node.left = __generateNode(node.left);\n      node.right = __generateNode(node.right);\n      // assign node type\n      // check types\n      node.type = util.typeCheck(node.left, node.right);\n      // error\n      if (!node.type) {\n        return __logError(node, node.location, 'type_mismatch', [node.operator, node.left.type, node.right.type]);\n      }\n      return node;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      var result = __generateNode(node.left);\n      // eval asignment right hand side\n      result += ' = ' + __generateNode(node.right);\n      return result;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      var result = ' {\\n';\n\n      indentManager.increase();\n\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item) + ';\\n';\n      });\n\n      indentManager.decrease();\n      \n      result += '}\\n';\n\n      return result;\n    },\n\n    PROGRAM: function (node) {\n      var result = '';\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item);\n        if (!result.match(/\\}\\n$/)) {\n          result += ';';\n        }\n        result += '\\n';\n      });\n      \n      return result;\n    },\n\n    IF_STATEMENT: function (node) {\n\n      var result = ' if ( ';\n\n      result += __generateNode(node.test);\n\n      result += ' ) ';\n      \n      result += __generateNode(node.consequent);\n\n      if (node.alternate) {\n      result += ' else ';\n        result += __generateNode(node.alternate);\n      }\n      return result;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      node.left = __generateNode(node.left);\n      node.right = __generateNode(node.right);\n\n      var result = node.left + ' ' + node.operator + ' ' + node.right;\n      return result;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      node.argument = __generateNode(node.argument);\n      if (!util.isNumber(node.argument.type)) {\n        // error\n        return __logError(node, node.location, 'not_a_number');\n      }\n      node.type = node.argument.type; \n      return node;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      node.argument = __generateNode(node.argument);\n      var cType = util.typeCheck(node.argument);\n      if (cType !== 'bool') {\n        // error\n        return __logError(node, node.location, 'not_a_bool');\n      }\n      return node;\n    }\n\n  };\n\n  // :: SPARK EVALUATOR\n\n  return {\n    parse: function (tree) {\n      console.log('tree 2:')\n      console.log(tree)\n\n      var code = __generateNode(tree);\n      return code.trim();\n    }\n  };\n\n})(this);\n},{\"./modules/GeneratorUtil\":2,\"./modules/IndentManager\":3}],2:[function(require,module,exports){\n(function (exports) {\n  // :: UTIL\n  'use strict';\n\n  var typeMap = {\n    'byte'  : 'char',\n    'ubyte' : 'unsigned char',\n    'int'   : 'int',\n    'uint'  : 'unsigned int',\n    'long'  : 'long',\n    'ulong' : 'unsigned long',\n    'float' : 'float',\n    'str'   : 'char',\n    'void'  : 'void',\n  };\n\n  var api = {\n    generateType: function (type) {\n      return typeMap[type] || type;\n    }\n  };\n\n  // :: EXPORT\n  module.exports.GeneratorUtil = api;\n\n})(exports || this);\n},{}],3:[function(require,module,exports){\n(function (exports) {\n  // :: INDENT MANAGER\n  'use strict';\n\n  var indentLevel = 0;\n  var indentChar = '  ';\n  var currentIndent = '';\n\n  var api = {\n    getCurrentIndent: function () {\n      return currentIndent;\n    },\n    increase: function () {\n      indentLevel += 1;\n      currentIndent = Array(indentLevel + 1).join(indentChar);\n    },\n    decrease: function () {\n      indentLevel -= 1;\n      currentIndent = Array(indentLevel + 1).join(indentChar);\n    }\n  }\n\n  // :: EXPORT\n  module.exports.IndentManager = api;\n\n})(this);\n},{}]},{},[1])\n\n","(function (exports) {\n  // :: UTIL\n  'use strict';\n\n  var typeMap = {\n    'byte'  : 'char',\n    'ubyte' : 'unsigned char',\n    'int'   : 'int',\n    'uint'  : 'unsigned int',\n    'long'  : 'long',\n    'ulong' : 'unsigned long',\n    'float' : 'float',\n    'str'   : 'char',\n    'void'  : 'void',\n  };\n\n  var api = {\n    generateType: function (type) {\n      return typeMap[type] || type;\n    }\n  };\n\n  // :: EXPORT\n  module.exports.GeneratorUtil = api;\n\n})(exports || this);","(function (exports) {\n  // :: INDENT MANAGER\n  'use strict';\n\n  var indentLevel = 0;\n  var indentChar = '  ';\n  var currentIndent = '';\n\n  var api = {\n    getCurrentIndent: function () {\n      return currentIndent;\n    },\n    increase: function () {\n      indentLevel += 1;\n      currentIndent = Array(indentLevel + 1).join(indentChar);\n    },\n    decrease: function () {\n      indentLevel -= 1;\n      currentIndent = Array(indentLevel + 1).join(indentChar);\n    }\n  }\n\n  // :: EXPORT\n  module.exports.IndentManager = api;\n\n})(this);"],"sourceRoot":"/source/"}