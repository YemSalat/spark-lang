{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/common/functions.js","generator.js","src/generator/generator.js","src/generator/modules/GeneratorUtil.js","src/generator/modules/IndentManager.js","src/generator/modules/UseWatcher.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","api","DEFAULT_FUNCTIONS","millis","pinRead","pinWrite","pinMode","print","println",2,"global","GeneratorError","name","message","location","this","useWatcher","indentManager","util","__generateNode","node","method","mType","pNode","evaluate","error","__preProcess","result","isUsed","__postProcess","trim","replace","parse","tree","reset","DOCSTRING","body","join","VARIABLE_STATEMENT","generateType","type","decs","declarations","item","curDec","varPostfix","id","init","push","VARIABLE_DECLARATOR","FUNCTION_DECLARATION","doc","fnParams","params","prm","PARAM_DECLARATOR","generateVarDeclaration","RETURN_STATEMENT","argument","CALL_STATEMENT","fName","callee","hasOwnProperty","add","args","curArg","FOR_STATEMENT","test","update","BREAK_STATEMENT","CONTINUE_STATEMENT","EXPRESSION_STATEMENT","expression","IDENTIFIER","LITERAL","value","BINARY_EXPRESSION","left","operator","right","ASSIGNMENT_STATEMENT","ASSIGNMENT_ACTION","BLOCK_STATEMENT","increase","forEach","getCurrentIndent","match","decrease","PROGRAM","IF_STATEMENT","consequent","alternate","LOGICAL_EXPRESSION","UPDATE_EXPRESSION","prefix","UNARY_EXPRESSION","SparkGenerator","self","window","./../common/functions","./modules/GeneratorUtil","./modules/IndentManager","./modules/UseWatcher",3,"typeMap","byte","ubyte","int","uint","long","ulong","float","str","void","typeDescriptors","isArray","isString","td",4,"indentLevel","indentChar","currentIndent","Array",5,"uses","func","indexOf","getUses"],"mappings":"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","file":"generator.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = (function () {\n  // :: CONSTANTS\n  'use strict';\n  \n  var api = {\n      DEFAULT_FUNCTIONS: {\n      millis: 'millis',\n      pinRead: 'digitalRead',\n      pinWrite: 'digitalWrite',\n      pinMode: 'pinMode',\n      print: 'Serial.print',\n      println: 'Serial.println'\n    }\n  };\n\n  return api;\n\n})();","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = (function () {\n  // :: CONSTANTS\n  'use strict';\n  \n  var api = {\n      DEFAULT_FUNCTIONS: {\n      millis: 'millis',\n      pinRead: 'digitalRead',\n      pinWrite: 'digitalWrite',\n      pinMode: 'pinMode',\n      print: 'Serial.print',\n      println: 'Serial.println'\n    }\n  };\n\n  return api;\n\n})();\n},{}],2:[function(require,module,exports){\n(function (global){\nmodule.exports = (function() {\n  'use strict';\n\n  // :: MODULES\n  var useWatcher = require('./modules/UseWatcher');\n  var indentManager = require('./modules/IndentManager');\n  var util = require('./modules/GeneratorUtil');\n\n  // :: CONSTANTS\n  var DEFAULT_FUNCTIONS = require('./../common/functions').DEFAULT_FUNCTIONS;\n\n  // :: ERRORS\n  function GeneratorError (name, message, location) {\n    this.name = name;\n    this.message = message;\n    this.location = location;\n  }\n\n  // :: PRIVATE\n  // generate c++ code for parse tree node\n  var __generateNode = function (node, method) {\n    if (node === null) {\n      return '';\n    }\n    var mType = method || node['$$'];\n    var pNode = evaluate[mType](node);\n    if (pNode.error) {\n      throw new GeneratorError('SemanticError', pNode.error.message, pNode.error.location);\n    }\n    return pNode;\n  };\n\n\n\n  // pre-process output\n  var __preProcess = function (code) {\n    var result = '';\n    // @TODO: Refactor\n    if (useWatcher.isUsed('print') || useWatcher.isUsed('println')) {\n      result = 'Serial.begin( 9600 );\\n\\n';\n    }\n\n    result = result + code;\n\n    return result;\n  };\n\n  // post-process output\n  var __postProcess = function (code) {\n    var result = code.trim().replace(/([a-z0-9])[ ]+/gi, '$1 ');\n    return result;\n  };\n\n\n  // :: API\n  var api = {\n    parse: function (tree) {\n      var code;\n\n      // reset uses watcher\n      useWatcher.reset();\n      \n      code = __generateNode(tree);\n      code = __preProcess(code);\n      code = __postProcess(code);\n\n      return code;\n    }\n  };\n\n  // :: GENERATE\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return '// ' + node.body.join('\\n// ') + '\\n';\n    },\n    \n    VARIABLE_STATEMENT: function(node) {\n      var result = util.generateType(node.type) + ' ';\n\n      var decs = [];\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n        var curDec = '';\n        \n        var varPostfix = '';\n        if (item.type === 'str') {\n          varPostfix = '[]';\n        }\n        curDec += __generateNode(item.id) + varPostfix;\n\n        if (item.init) {\n\n          curDec += ' = ' + __generateNode(item.init);\n        }\n\n        decs.push( curDec );\n      }\n\n      result += decs.join(', ');\n\n      return result;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n    FUNCTION_DECLARATION: function (node) {\n      var result = '';\n      if (node.doc) {\n        result += __generateNode(node.doc);\n      }\n\n      result += node.type + ' ' + node.id.name + ' ( ';\n\n      var fnParams = [];\n      for (var i=0, l=node.params.length; i<l; i++) {\n        var prm = __generateNode(node.params[i]);\n        fnParams.push(prm);\n      }\n\n      result += fnParams.join(', ');\n\n      result += ' ) ';\n\n      // parse function body\n      result += __generateNode(node.body);\n      \n      return result;\n    },\n\n    PARAM_DECLARATOR: function (node) {\n      var result = util.generateVarDeclaration(node);\n      return result;\n    },\n\n    RETURN_STATEMENT: function (node) {\n      var result = 'return ' + __generateNode(node.argument);\n      return result;\n    },\n\n    CALL_STATEMENT: function (node) {\n      var fName = node.callee.name;\n      var result = fName;\n      if (DEFAULT_FUNCTIONS.hasOwnProperty(fName)) {\n        result = DEFAULT_FUNCTIONS[fName];\n        useWatcher.add(fName);\n      }\n\n      // output arguments\n      result += '(';\n\n      var args = [];\n      for (var i=0, l=node['arguments'].length; i<l; i++) {\n        var curArg = node['arguments'][i];\n        args.push(__generateNode(curArg));\n      }\n      if (args.length > 0) {\n        result += ' ' + args.join(', ') + ' ';\n      }\n\n      result += ')';\n\n      return result;\n    },\n\n    FOR_STATEMENT: function (node) {\n      var result = 'for (';\n      result += __generateNode(node.init) + ' ; ';\n      result += __generateNode(node.test) + ' ; ';\n      result += __generateNode(node.update) + ' )';\n      result += __generateNode(node.body);\n      return result;\n    },\n\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n    EXPRESSION_STATEMENT: function (node) {\n      var result = __generateNode(node.expression);\n      return result;\n    },\n\n    IDENTIFIER: function (node) {\n      return node.name;\n    },\n\n    LITERAL: function(node) {\n      var result = node.value;\n      if (node.type === 'str') {\n        result = '\"' + result + '\"';\n      }\n      return result;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      var result = '';\n      // eval left and right parts first\n      result += __generateNode(node.left);\n      result += ' ' + node.operator + ' ';\n      result += __generateNode(node.right);\n      return result;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      var result = __generateNode(node.left);\n      // eval asignment right hand side\n      result += ' = ' + __generateNode(node.right);\n      return result;\n    },\n\n    ASSIGNMENT_ACTION: function (node) {\n      var result = __generateNode(node.left);\n      // eval asignment right hand side\n      result += ' '+ node.operator +' ' + __generateNode(node.right);\n      return result;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      var result = ' {\\n';\n\n      indentManager.increase();\n\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item);\n        if (!result.match(/\\}\\s*$/g)) {\n          result += ';\\n';\n        }\n        if (!result.match(/\\n\\s*$/g)) {\n          result += '\\n';\n        }\n      });\n\n      indentManager.decrease();\n      \n      result += indentManager.getCurrentIndent() + '}\\n';\n\n      return result;\n    },\n\n    PROGRAM: function (node) {\n      var result = '';\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item);\n        if (!result.match(/\\}\\s*$/g)) {\n          result += ';';\n        }\n        result += '\\n';\n      });\n      \n      return result;\n    },\n\n    IF_STATEMENT: function (node) {\n\n      var result = 'if ( ';\n\n      result += __generateNode(node.test);\n      result += ' )';\n      result += __generateNode(node.consequent);\n\n      if (node.alternate) {\n      result += indentManager.getCurrentIndent() + 'else ';\n        result += __generateNode(node.alternate);\n      }\n      return result;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      var result = __generateNode(node.left) + ' ' + node.operator + ' ' + __generateNode(node.right);\n      return result;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      var result = '';\n      if (node.prefix) {\n        result += node.operator + __generateNode(node.argument);\n      }\n      else {\n        result += __generateNode(node.argument) + node.operator;\n      }\n      return result;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      var result = node.operator + '';\n      result += __generateNode(node.argument);\n      return result;\n    }\n\n  };\n\n  // :: SPARK GENERATOR\n  global.SparkGenerator = api;\n  return api;\n\n})();\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./../common/functions\":1,\"./modules/GeneratorUtil\":3,\"./modules/IndentManager\":4,\"./modules/UseWatcher\":5}],3:[function(require,module,exports){\nmodule.exports = (function () {\n  'use strict';\n\n  // :: PRIVATE\n  var typeMap = {\n    'byte'  : 'char',\n    'ubyte' : 'unsigned char',\n    'int'   : 'int',\n    'uint'  : 'unsigned int',\n    'long'  : 'long',\n    'ulong' : 'unsigned long',\n    'float' : 'float',\n    'str'   : 'char',\n    'void'  : 'void',\n  };\n  var typeDescriptors = {\n    'str' : {\n      isArray: true,\n      isString: true\n    }\n  };\n\n  // :: API\n  var api = {\n    generateType: function (type) {\n      return typeMap[type] || type;\n    },\n\n    generateVarDeclaration: function (node) {\n      var type = api.generateType(node.type);\n      var name = node.id.name;\n      if (typeDescriptors.hasOwnProperty(node.type)) {\n        var td = typeDescriptors[node.type];\n        if (td.isArray) {\n          return type + ' ' + name + '[]';\n        }\n      }\n      return type + ' ' + name;\n    } \n  };\n\n  // :: EXPORT\n  return api;\n\n})();\n},{}],4:[function(require,module,exports){\nmodule.exports = (function () {\n  'use strict';\n\n  // :: PRIVATE\n  var indentLevel = 0;\n  var indentChar = '  ';\n  var currentIndent = '';\n\n  // :: API\n  var api = {\n\n    getCurrentIndent: function () {\n      return currentIndent;\n    },\n    \n    increase: function () {\n      indentLevel += 1;\n      currentIndent = new Array(indentLevel + 1).join(indentChar);\n    },\n\n    decrease: function () {\n      indentLevel -= 1;\n      currentIndent = new Array(indentLevel + 1).join(indentChar);\n    }\n  };\n\n  // :: EXPORT\n  return api;\n\n})();\n},{}],5:[function(require,module,exports){\nmodule.exports = (function () {\n  'use strict';\n\n  // :: PRIVATE\n  var uses = [];\n\n  // :: API\n  var api = {\n    add: function (func) {\n      if (uses.indexOf(func) === -1) {\n        uses.push(func);\n        return func;\n      }\n      return false;\n    },\n\n    isUsed: function (func) {\n      return uses.indexOf(func) > -1;\n    },\n\n    getUses: function () {\n      return uses;\n    },\n\n    reset: function () {\n      uses = [];\n    }\n  };\n  \n  // :: EXPORT\n  return api;\n\n})();\n},{}]},{},[2])\n\n","module.exports = (function() {\n  'use strict';\n\n  // :: MODULES\n  var useWatcher = require('./modules/UseWatcher');\n  var indentManager = require('./modules/IndentManager');\n  var util = require('./modules/GeneratorUtil');\n\n  // :: CONSTANTS\n  var DEFAULT_FUNCTIONS = require('./../common/functions').DEFAULT_FUNCTIONS;\n\n  // :: ERRORS\n  function GeneratorError (name, message, location) {\n    this.name = name;\n    this.message = message;\n    this.location = location;\n  }\n\n  // :: PRIVATE\n  // generate c++ code for parse tree node\n  var __generateNode = function (node, method) {\n    if (node === null) {\n      return '';\n    }\n    var mType = method || node['$$'];\n    var pNode = evaluate[mType](node);\n    if (pNode.error) {\n      throw new GeneratorError('SemanticError', pNode.error.message, pNode.error.location);\n    }\n    return pNode;\n  };\n\n\n\n  // pre-process output\n  var __preProcess = function (code) {\n    var result = '';\n    // @TODO: Refactor\n    if (useWatcher.isUsed('print') || useWatcher.isUsed('println')) {\n      result = 'Serial.begin( 9600 );\\n\\n';\n    }\n\n    result = result + code;\n\n    return result;\n  };\n\n  // post-process output\n  var __postProcess = function (code) {\n    var result = code.trim().replace(/([a-z0-9])[ ]+/gi, '$1 ');\n    return result;\n  };\n\n\n  // :: API\n  var api = {\n    parse: function (tree) {\n      var code;\n\n      // reset uses watcher\n      useWatcher.reset();\n      \n      code = __generateNode(tree);\n      code = __preProcess(code);\n      code = __postProcess(code);\n\n      return code;\n    }\n  };\n\n  // :: GENERATE\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return '// ' + node.body.join('\\n// ') + '\\n';\n    },\n    \n    VARIABLE_STATEMENT: function(node) {\n      var result = util.generateType(node.type) + ' ';\n\n      var decs = [];\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n        var curDec = '';\n        \n        var varPostfix = '';\n        if (item.type === 'str') {\n          varPostfix = '[]';\n        }\n        curDec += __generateNode(item.id) + varPostfix;\n\n        if (item.init) {\n\n          curDec += ' = ' + __generateNode(item.init);\n        }\n\n        decs.push( curDec );\n      }\n\n      result += decs.join(', ');\n\n      return result;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n    FUNCTION_DECLARATION: function (node) {\n      var result = '';\n      if (node.doc) {\n        result += __generateNode(node.doc);\n      }\n\n      result += node.type + ' ' + node.id.name + ' ( ';\n\n      var fnParams = [];\n      for (var i=0, l=node.params.length; i<l; i++) {\n        var prm = __generateNode(node.params[i]);\n        fnParams.push(prm);\n      }\n\n      result += fnParams.join(', ');\n\n      result += ' ) ';\n\n      // parse function body\n      result += __generateNode(node.body);\n      \n      return result;\n    },\n\n    PARAM_DECLARATOR: function (node) {\n      var result = util.generateVarDeclaration(node);\n      return result;\n    },\n\n    RETURN_STATEMENT: function (node) {\n      var result = 'return ' + __generateNode(node.argument);\n      return result;\n    },\n\n    CALL_STATEMENT: function (node) {\n      var fName = node.callee.name;\n      var result = fName;\n      if (DEFAULT_FUNCTIONS.hasOwnProperty(fName)) {\n        result = DEFAULT_FUNCTIONS[fName];\n        useWatcher.add(fName);\n      }\n\n      // output arguments\n      result += '(';\n\n      var args = [];\n      for (var i=0, l=node['arguments'].length; i<l; i++) {\n        var curArg = node['arguments'][i];\n        args.push(__generateNode(curArg));\n      }\n      if (args.length > 0) {\n        result += ' ' + args.join(', ') + ' ';\n      }\n\n      result += ')';\n\n      return result;\n    },\n\n    FOR_STATEMENT: function (node) {\n      var result = 'for (';\n      result += __generateNode(node.init) + ' ; ';\n      result += __generateNode(node.test) + ' ; ';\n      result += __generateNode(node.update) + ' )';\n      result += __generateNode(node.body);\n      return result;\n    },\n\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n    EXPRESSION_STATEMENT: function (node) {\n      var result = __generateNode(node.expression);\n      return result;\n    },\n\n    IDENTIFIER: function (node) {\n      return node.name;\n    },\n\n    LITERAL: function(node) {\n      var result = node.value;\n      if (node.type === 'str') {\n        result = '\"' + result + '\"';\n      }\n      return result;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      var result = '';\n      // eval left and right parts first\n      result += __generateNode(node.left);\n      result += ' ' + node.operator + ' ';\n      result += __generateNode(node.right);\n      return result;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      var result = __generateNode(node.left);\n      // eval asignment right hand side\n      result += ' = ' + __generateNode(node.right);\n      return result;\n    },\n\n    ASSIGNMENT_ACTION: function (node) {\n      var result = __generateNode(node.left);\n      // eval asignment right hand side\n      result += ' '+ node.operator +' ' + __generateNode(node.right);\n      return result;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      var result = ' {\\n';\n\n      indentManager.increase();\n\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item);\n        if (!result.match(/\\}\\s*$/g)) {\n          result += ';\\n';\n        }\n        if (!result.match(/\\n\\s*$/g)) {\n          result += '\\n';\n        }\n      });\n\n      indentManager.decrease();\n      \n      result += indentManager.getCurrentIndent() + '}\\n';\n\n      return result;\n    },\n\n    PROGRAM: function (node) {\n      var result = '';\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item);\n        if (!result.match(/\\}\\s*$/g)) {\n          result += ';';\n        }\n        result += '\\n';\n      });\n      \n      return result;\n    },\n\n    IF_STATEMENT: function (node) {\n\n      var result = 'if ( ';\n\n      result += __generateNode(node.test);\n      result += ' )';\n      result += __generateNode(node.consequent);\n\n      if (node.alternate) {\n      result += indentManager.getCurrentIndent() + 'else ';\n        result += __generateNode(node.alternate);\n      }\n      return result;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      var result = __generateNode(node.left) + ' ' + node.operator + ' ' + __generateNode(node.right);\n      return result;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      var result = '';\n      if (node.prefix) {\n        result += node.operator + __generateNode(node.argument);\n      }\n      else {\n        result += __generateNode(node.argument) + node.operator;\n      }\n      return result;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      var result = node.operator + '';\n      result += __generateNode(node.argument);\n      return result;\n    }\n\n  };\n\n  // :: SPARK GENERATOR\n  global.SparkGenerator = api;\n  return api;\n\n})();","module.exports = (function () {\n  'use strict';\n\n  // :: PRIVATE\n  var typeMap = {\n    'byte'  : 'char',\n    'ubyte' : 'unsigned char',\n    'int'   : 'int',\n    'uint'  : 'unsigned int',\n    'long'  : 'long',\n    'ulong' : 'unsigned long',\n    'float' : 'float',\n    'str'   : 'char',\n    'void'  : 'void',\n  };\n  var typeDescriptors = {\n    'str' : {\n      isArray: true,\n      isString: true\n    }\n  };\n\n  // :: API\n  var api = {\n    generateType: function (type) {\n      return typeMap[type] || type;\n    },\n\n    generateVarDeclaration: function (node) {\n      var type = api.generateType(node.type);\n      var name = node.id.name;\n      if (typeDescriptors.hasOwnProperty(node.type)) {\n        var td = typeDescriptors[node.type];\n        if (td.isArray) {\n          return type + ' ' + name + '[]';\n        }\n      }\n      return type + ' ' + name;\n    } \n  };\n\n  // :: EXPORT\n  return api;\n\n})();","module.exports = (function () {\n  'use strict';\n\n  // :: PRIVATE\n  var indentLevel = 0;\n  var indentChar = '  ';\n  var currentIndent = '';\n\n  // :: API\n  var api = {\n\n    getCurrentIndent: function () {\n      return currentIndent;\n    },\n    \n    increase: function () {\n      indentLevel += 1;\n      currentIndent = new Array(indentLevel + 1).join(indentChar);\n    },\n\n    decrease: function () {\n      indentLevel -= 1;\n      currentIndent = new Array(indentLevel + 1).join(indentChar);\n    }\n  };\n\n  // :: EXPORT\n  return api;\n\n})();","module.exports = (function () {\n  'use strict';\n\n  // :: PRIVATE\n  var uses = [];\n\n  // :: API\n  var api = {\n    add: function (func) {\n      if (uses.indexOf(func) === -1) {\n        uses.push(func);\n        return func;\n      }\n      return false;\n    },\n\n    isUsed: function (func) {\n      return uses.indexOf(func) > -1;\n    },\n\n    getUses: function () {\n      return uses;\n    },\n\n    reset: function () {\n      uses = [];\n    }\n  };\n  \n  // :: EXPORT\n  return api;\n\n})();"],"sourceRoot":"/source/"}