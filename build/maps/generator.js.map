{"version":3,"sources":["node_modules/browser-pack/_prelude.js","generator.js","src/generator/generator.js","src/generator/modules/GeneratorUtil.js","src/generator/modules/IndentManager.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","global","indentManager","util","__generateNode","node","method","mType","pNode","evaluate","error","CompilerError","message","location","__processOutput","result","trim","replace","api","parse","tree","DOCSTRING","body","join","VARIABLE_STATEMENT","generateType","type","decs","declarations","item","curDec","varPostfix","id","init","push","VARIABLE_DECLARATOR","FUNCTION_DECLARATION","doc","name","fnParams","params","prm","PARAM_DECLARATOR","generateVarDecalaration","RETURN_STATEMENT","argument","CALL_STATEMENT","FOR_STATEMENT","test","update","BREAK_STATEMENT","CONTINUE_STATEMENT","EXPRESSION_STATEMENT","expression","IDENTIFIER","LITERAL","value","BINARY_EXPRESSION","left","operator","right","ASSIGNMENT_STATEMENT","BLOCK_STATEMENT","increase","forEach","getCurrentIndent","decrease","PROGRAM","match","IF_STATEMENT","consequent","alternate","LOGICAL_EXPRESSION","UPDATE_EXPRESSION","prefix","UNARY_EXPRESSION","SparkGenerator","this","self","window","./modules/GeneratorUtil","./modules/IndentManager",2,"typeMap","byte","ubyte","int","uint","long","ulong","float","str","void","typeDescriptors","isArray","isString","generateVarDeclaration","hasOwnProperty","td",3,"indentLevel","indentChar","currentIndent","Array"],"mappings":"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","file":"generator.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\nmodule.exports = (function() {\n  'use strict';\n\n  // :: MODULES\n  var indentManager = require('./modules/IndentManager');\n  var util = require('./modules/GeneratorUtil');\n\n  // :: OP\n  var __generateNode = function(node, method) {\n    if (node === null) {\n      return '';\n    }\n    var mType = method || node['$$'];\n    var pNode = evaluate[mType](node)\n    if (pNode.error) {\n      throw new CompilerError('SemanticError', pNode.error.message, pNode.error.location);\n    }\n    return pNode;\n  };\n\n  var __processOutput = function (code) {\n    var result = code.trim().replace(/(?!^)[ ]+/igm, ' ');\n    return result;\n  };\n\n  // :: API\n  var api = {\n    parse: function (tree) {\n      var code;\n      \n      code = __generateNode(tree);\n      code = __processOutput(code);\n\n      return code;\n    }\n  };\n\n  // :: GENERATE\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return '// ' + node.body.join('\\n// ') + '\\n';\n    },\n    \n    VARIABLE_STATEMENT: function(node) {\n      var result = util.generateType(node.type) + ' ';\n\n      var decs = [];\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n        var curDec = '';\n        \n        var varPostfix = '';\n        if (item.type === 'str') {\n          varPostfix = '[]';\n        }\n        curDec += __generateNode(item.id) + varPostfix;\n\n        if (item.init) {\n\n          curDec += ' = ' + __generateNode(item.init);\n        }\n\n        decs.push( curDec );\n      }\n\n      result += decs.join(', ');\n\n      return result;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n\n    FUNCTION_DECLARATION: function (node) {\n      var result = ''\n      if (node.doc) {\n        result += __generateNode(node.doc);\n      }\n\n      result += node.type + ' ' + node.id.name + ' ( ';\n\n      var fnParams = [];\n      for (var i=0, l=node.params.length; i<l; i++) {\n        var prm = __generateNode(node.params[i]);\n        fnParams.push(prm);\n      }\n\n      result += fnParams.join(', ');\n\n      result += ' ) '\n\n      // parse function body\n      result += __generateNode(node.body);\n      \n      return result;\n    },\n    PARAM_DECLARATOR: function (node) {\n\n      var result = util.generateVarDecalaration(node);\n      return result;\n    },\n    RETURN_STATEMENT: function (node) {\n      var result = 'return ' + __generateNode(node.argument);\n      return result;\n    },\n    CALL_STATEMENT: function (node) {\n      var result = node.name;\n      return result;\n    },\n\n\n    FOR_STATEMENT: function (node) {\n      var result = 'for (';\n      result += __generateNode(node.init) + ' ; ';\n      result += __generateNode(node.test) + ' ; ';\n      result += __generateNode(node.update) + ' )';\n      result += __generateNode(node.body);\n      return result;\n    },\n\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n\n    EXPRESSION_STATEMENT: function (node) {\n      var result = __generateNode(node.expression);\n      return result;\n    },\n\n    IDENTIFIER: function (node) {\n      return node.name;\n    },\n\n    LITERAL: function(node) {\n      var result = node.value;\n      if (node.type === 'str') {\n        result = '\"' + result + '\"';\n      }\n      return result;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      var result = '';\n      // eval left and right parts first\n      result += __generateNode(node.left);\n      result += ' ' + node.operator + ' ';\n      result += __generateNode(node.right);\n      return result;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      var result = __generateNode(node.left);\n      // eval asignment right hand side\n      result += ' = ' + __generateNode(node.right);\n      return result;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      var result = ' {\\n';\n\n      indentManager.increase();\n\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item) + ';\\n';\n      });\n\n      indentManager.decrease();\n      \n      result += '}\\n';\n\n      return result;\n    },\n\n    PROGRAM: function (node) {\n      var result = '';\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item);\n        if (!result.match(/\\}[\\s]*$/)) {\n          result += ';';\n        }\n        result += '\\n';\n      });\n      \n      return result;\n    },\n\n    IF_STATEMENT: function (node) {\n\n      var result = 'if ( ';\n\n      result += __generateNode(node.test);\n\n      result += ' )';\n      \n      result += __generateNode(node.consequent);\n\n      if (node.alternate) {\n      result += 'else ';\n        result += __generateNode(node.alternate);\n      }\n      return result;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      var result = __generateNode(node.left) + ' ' + node.operator + ' ' + __generateNode(node.right);\n      return result;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      var result = '';\n      if (node.prefix) {\n        result += node.operator + __generateNode(node.argument);\n      }\n      else {\n        result += __generateNode(node.argument) + node.operator;\n      }\n      return result;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      var result = node.operator + '';\n      result += __generateNode(node.argument);\n      return result;\n    }\n\n  };\n\n  // :: SPARK GENERATOR\n  global.SparkGenerator = api;\n  return api;\n\n})();\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./modules/GeneratorUtil\":2,\"./modules/IndentManager\":3}],2:[function(require,module,exports){\nmodule.exports = (function () {\n  // :: UTIL\n  'use strict';\n\n  var typeMap = {\n    'byte'  : 'char',\n    'ubyte' : 'unsigned char',\n    'int'   : 'int',\n    'uint'  : 'unsigned int',\n    'long'  : 'long',\n    'ulong' : 'unsigned long',\n    'float' : 'float',\n    'str'   : 'char',\n    'void'  : 'void',\n  };\n\n  var typeDescriptors = {\n    'str' : {\n      isArray: true,\n      isString: true\n    }\n  }\n\n  var api = {\n    generateType: function (type) {\n      return typeMap[type] || type;\n    },\n\n    generateVarDeclaration: function (node) {\n      var type = api.generateType(node.type);\n      var name = node.id.name;\n      if (typeDescriptors.hasOwnProperty(node.type)) {\n        var td = typeDescriptors[node.type];\n        if (td.isArray) {\n          return type + ' ' + name + '[]';\n        }\n      }\n      return type + ' ' + name;\n    } \n  };\n\n  // :: EXPORT\n  return api;\n\n})();\n},{}],3:[function(require,module,exports){\nmodule.exports = (function () {\n  // :: INDENT MANAGER\n  'use strict';\n\n  var indentLevel = 0;\n  var indentChar = '  ';\n  var currentIndent = '';\n\n  var api = {\n    getCurrentIndent: function () {\n      return currentIndent;\n    },\n    increase: function () {\n      indentLevel += 1;\n      currentIndent = Array(indentLevel + 1).join(indentChar);\n    },\n    decrease: function () {\n      indentLevel -= 1;\n      currentIndent = Array(indentLevel + 1).join(indentChar);\n    }\n  }\n\n  // :: EXPORT\n  return api;\n\n})();\n},{}]},{},[1])\n\n","module.exports = (function() {\n  'use strict';\n\n  // :: MODULES\n  var indentManager = require('./modules/IndentManager');\n  var util = require('./modules/GeneratorUtil');\n\n  // :: OP\n  var __generateNode = function(node, method) {\n    if (node === null) {\n      return '';\n    }\n    var mType = method || node['$$'];\n    var pNode = evaluate[mType](node)\n    if (pNode.error) {\n      throw new CompilerError('SemanticError', pNode.error.message, pNode.error.location);\n    }\n    return pNode;\n  };\n\n  var __processOutput = function (code) {\n    var result = code.trim().replace(/(?!^)[ ]+/igm, ' ');\n    return result;\n  };\n\n  // :: API\n  var api = {\n    parse: function (tree) {\n      var code;\n      \n      code = __generateNode(tree);\n      code = __processOutput(code);\n\n      return code;\n    }\n  };\n\n  // :: GENERATE\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return '// ' + node.body.join('\\n// ') + '\\n';\n    },\n    \n    VARIABLE_STATEMENT: function(node) {\n      var result = util.generateType(node.type) + ' ';\n\n      var decs = [];\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n        var curDec = '';\n        \n        var varPostfix = '';\n        if (item.type === 'str') {\n          varPostfix = '[]';\n        }\n        curDec += __generateNode(item.id) + varPostfix;\n\n        if (item.init) {\n\n          curDec += ' = ' + __generateNode(item.init);\n        }\n\n        decs.push( curDec );\n      }\n\n      result += decs.join(', ');\n\n      return result;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n\n    FUNCTION_DECLARATION: function (node) {\n      var result = ''\n      if (node.doc) {\n        result += __generateNode(node.doc);\n      }\n\n      result += node.type + ' ' + node.id.name + ' ( ';\n\n      var fnParams = [];\n      for (var i=0, l=node.params.length; i<l; i++) {\n        var prm = __generateNode(node.params[i]);\n        fnParams.push(prm);\n      }\n\n      result += fnParams.join(', ');\n\n      result += ' ) '\n\n      // parse function body\n      result += __generateNode(node.body);\n      \n      return result;\n    },\n    PARAM_DECLARATOR: function (node) {\n\n      var result = util.generateVarDecalaration(node);\n      return result;\n    },\n    RETURN_STATEMENT: function (node) {\n      var result = 'return ' + __generateNode(node.argument);\n      return result;\n    },\n    CALL_STATEMENT: function (node) {\n      var result = node.name;\n      return result;\n    },\n\n\n    FOR_STATEMENT: function (node) {\n      var result = 'for (';\n      result += __generateNode(node.init) + ' ; ';\n      result += __generateNode(node.test) + ' ; ';\n      result += __generateNode(node.update) + ' )';\n      result += __generateNode(node.body);\n      return result;\n    },\n\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n\n    EXPRESSION_STATEMENT: function (node) {\n      var result = __generateNode(node.expression);\n      return result;\n    },\n\n    IDENTIFIER: function (node) {\n      return node.name;\n    },\n\n    LITERAL: function(node) {\n      var result = node.value;\n      if (node.type === 'str') {\n        result = '\"' + result + '\"';\n      }\n      return result;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      var result = '';\n      // eval left and right parts first\n      result += __generateNode(node.left);\n      result += ' ' + node.operator + ' ';\n      result += __generateNode(node.right);\n      return result;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      var result = __generateNode(node.left);\n      // eval asignment right hand side\n      result += ' = ' + __generateNode(node.right);\n      return result;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      var result = ' {\\n';\n\n      indentManager.increase();\n\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item) + ';\\n';\n      });\n\n      indentManager.decrease();\n      \n      result += '}\\n';\n\n      return result;\n    },\n\n    PROGRAM: function (node) {\n      var result = '';\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item);\n        if (!result.match(/\\}[\\s]*$/)) {\n          result += ';';\n        }\n        result += '\\n';\n      });\n      \n      return result;\n    },\n\n    IF_STATEMENT: function (node) {\n\n      var result = 'if ( ';\n\n      result += __generateNode(node.test);\n\n      result += ' )';\n      \n      result += __generateNode(node.consequent);\n\n      if (node.alternate) {\n      result += 'else ';\n        result += __generateNode(node.alternate);\n      }\n      return result;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      var result = __generateNode(node.left) + ' ' + node.operator + ' ' + __generateNode(node.right);\n      return result;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      var result = '';\n      if (node.prefix) {\n        result += node.operator + __generateNode(node.argument);\n      }\n      else {\n        result += __generateNode(node.argument) + node.operator;\n      }\n      return result;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      var result = node.operator + '';\n      result += __generateNode(node.argument);\n      return result;\n    }\n\n  };\n\n  // :: SPARK GENERATOR\n  global.SparkGenerator = api;\n  return api;\n\n})();","module.exports = (function () {\n  // :: UTIL\n  'use strict';\n\n  var typeMap = {\n    'byte'  : 'char',\n    'ubyte' : 'unsigned char',\n    'int'   : 'int',\n    'uint'  : 'unsigned int',\n    'long'  : 'long',\n    'ulong' : 'unsigned long',\n    'float' : 'float',\n    'str'   : 'char',\n    'void'  : 'void',\n  };\n\n  var typeDescriptors = {\n    'str' : {\n      isArray: true,\n      isString: true\n    }\n  }\n\n  var api = {\n    generateType: function (type) {\n      return typeMap[type] || type;\n    },\n\n    generateVarDeclaration: function (node) {\n      var type = api.generateType(node.type);\n      var name = node.id.name;\n      if (typeDescriptors.hasOwnProperty(node.type)) {\n        var td = typeDescriptors[node.type];\n        if (td.isArray) {\n          return type + ' ' + name + '[]';\n        }\n      }\n      return type + ' ' + name;\n    } \n  };\n\n  // :: EXPORT\n  return api;\n\n})();","module.exports = (function () {\n  // :: INDENT MANAGER\n  'use strict';\n\n  var indentLevel = 0;\n  var indentChar = '  ';\n  var currentIndent = '';\n\n  var api = {\n    getCurrentIndent: function () {\n      return currentIndent;\n    },\n    increase: function () {\n      indentLevel += 1;\n      currentIndent = Array(indentLevel + 1).join(indentChar);\n    },\n    decrease: function () {\n      indentLevel -= 1;\n      currentIndent = Array(indentLevel + 1).join(indentChar);\n    }\n  }\n\n  // :: EXPORT\n  return api;\n\n})();"],"sourceRoot":"/source/"}