{"version":3,"sources":["module.js","generator-indentmanager.js","generator-util.js","generator.js"],"names":["module","NAMESPACE","exportModule","importModule","name","obj","Error","checkModule","hasOwnProperty","this","moduleName","indentLevel","indentChar","currentIndent","api","getCurrentIndent","increase","Array","join","decrease","typeMap","byte","ubyte","int","uint","long","ulong","float","str","void","util","generateType","type","theGenerator","indentManager","__generateNode","node","method","mType","pNode","evaluate","error","CompilerError","message","location","DOCSTRING","body","VARIABLE_STATEMENT","result","i","l","declarations","length","item","varPostfix","id","init","VARIABLE_DECLARATOR","FUNCTION_DECLARATION","doc","fnParams","params","prm","push","PARAM_DECLARATOR","RETURN_STATEMENT","argument","CALL_STATEMENT","FOR_STATEMENT","FOR_STATEMENT_DECLARATION","BREAK_STATEMENT","CONTINUE_STATEMENT","EXPRESSION_STATEMENT","expression","IDENTIFIER","LITERAL","value","BINARY_EXPRESSION","left","right","typeCheck","__logError","operator","ASSIGNMENT_STATEMENT","BLOCK_STATEMENT","forEach","PROGRAM","match","IF_STATEMENT","test","consequent","alternate","LOGICAL_EXPRESSION","UPDATE_EXPRESSION","isNumber","UNARY_EXPRESSION","cType","parse","tree","console","log","code","trim"],"mappings":"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","file":"generator.js","sourcesContent":["(function (module) {\n\t// const\n\tvar NAMESPACE = 'SPARK_modules';\n\t\n\tif ( module[NAMESPACE] ) {\n\t\treturn;\n\t}\n\t// create namespace\n\tmodule[NAMESPACE] = {};\n\n\t// create import/export functions\n\tif ( !module.exportModule || !module.importModule ) {\n\t\t// export module\n\t\tmodule.exportModule = function (name, obj) {\n\t\t\tif (module[NAMESPACE][name]) {\n\t\t\t\tthrow new Error('Module '+ name +' already exists');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmodule[NAMESPACE][name] = obj;\n\t\t\t}\n\t\t};\n\t\t// import module\n\t\tmodule.importModule = function (name) {\n\t\t\treturn module[NAMESPACE][name];\n\t\t};\n\t\t// check module\n\t\tmodule.checkModule = function (name) {\n\t\t\treturn module[NAMESPACE].hasOwnProperty(name);\n\t\t};\n\t}\n\n\n})(this);","(function (module) {\n  var moduleName = 'IndentManager';\n  if (module.checkModule(moduleName)) {\n    return;\n  }\n  // :: INDENT MANAGER\n  'use strict';\n\n  var indentLevel = 0;\n  var indentChar = '  ';\n  var currentIndent = '';\n\n  var api = {\n    getCurrentIndent: function () {\n      return currentIndent;\n    },\n    increase: function () {\n      indentLevel += 1;\n      currentIndent = Array(indentLevel + 1).join(indentChar);\n    },\n    decrease: function () {\n      indentLevel -= 1;\n      currentIndent = Array(indentLevel + 1).join(indentChar);\n    }\n  }\n\n  // :: EXPORT\n  module.exportModule(moduleName, api);\n\n})(this);","(function (module) {\n  var moduleName = 'GeneratorUtil';\n  if (module.checkModule(moduleName)) {\n    return;\n  }\n  // :: UTIL\n  'use strict';\n\n  var typeMap = {\n    'byte'  : 'char',\n    'ubyte' : 'unsigned char',\n    'int'   : 'int',\n    'uint'  : 'unsigned int',\n    'long'  : 'long',\n    'ulong' : 'unsigned long',\n    'float' : 'float',\n    'str'   : 'char',\n    'void'  : 'void',\n  };\n\n  var util = {\n    generateType: function (type) {\n      return typeMap[type] || type;\n    }\n  };\n\n  // :: EXPORT\n  module.exportModule(moduleName, util);\n\n})(this);","var theGenerator = (function(module) {\n  'use strict';\n\n  // :: MODULES\n  var indentManager = module.importModule('IndentManager');\n  var util = module.importModule('GeneratorUtil');\n\n  // :: OP\n  var __generateNode = function(node, method) {\n    var mType = method || node['$$'];\n    var pNode = evaluate[mType](node)\n    if (pNode.error) {\n      throw new CompilerError('SemanticError', pNode.error.message, pNode.error.location);\n    }\n    return pNode;\n  };\n\n  // :: GENERATE\n  var evaluate = {\n\n    DOCSTRING: function(node) {\n      return '// ' + node.body.join('\\n// ') + '\\n';\n    },\n    \n    VARIABLE_STATEMENT: function(node) {\n      var result = util.generateType(node.type) + ' ';\n\n      for (var i=0,l=node.declarations.length; i<l; i++) {\n        var item = node.declarations[i];\n        \n        var varPostfix = '';\n        result += __generateNode(item.id) + varPostfix;\n\n        if (item.init) {\n          if (item.init.type === 'str') {\n            varPostfix = '[]';\n          }\n\n          result += ' = ' + __generateNode(item.init);\n        }\n      }\n\n      return result;\n    },\n\n    VARIABLE_DECLARATOR: function (node) {\n      return node;\n    },\n\n\n    FUNCTION_DECLARATION: function (node) {\n      var result = ''\n      if (node.doc) {\n        result += __generateNode(node.doc);\n      }\n\n      result += node.type + ' ' + node.id.name + ' ( ';\n\n      var fnParams = [];\n      for (var i=0, l=node.params.length; i<l; i++) {\n        var prm = __generateNode(node.params[i]);\n        fnParams.push(prm);\n      }\n\n      result += fnParams.join(', ');\n\n      result += ' ) '\n\n      // parse function body\n      result += __generateNode(node.body);\n      \n      return result;\n    },\n    PARAM_DECLARATOR: function (node) {\n      var result = util.generateType(node.type) + ' ' + node.id.name;\n      return result;\n    },\n    RETURN_STATEMENT: function (node) {\n      var result = 'return ' + __generateNode(node.argument);\n      return result;\n    },\n    CALL_STATEMENT: function (node) {\n      var result = node.name;\n      return result;\n    },\n\n\n\n    FOR_STATEMENT: function (node) {\n      return node;\n    },\n\n    FOR_STATEMENT_DECLARATION: function (node) {\n      return node;\n    },\n    BREAK_STATEMENT: function (node) {\n      return node;\n    },\n    CONTINUE_STATEMENT: function (node) {\n      return node;\n    },\n\n\n    EXPRESSION_STATEMENT: function (node) {\n      var result = __generateNode(node.expression);\n      return result;\n    },\n\n    IDENTIFIER: function (node) {\n      return node.name;\n    },\n\n    LITERAL: function(node) {\n      var result = node.value;\n      if (node.type === 'str') {\n        result = '\"' + result + '\"';\n      }\n      return result;\n    },\n\n    BINARY_EXPRESSION: function (node) {\n      // eval left and right parts first\n      node.left = __generateNode(node.left);\n      node.right = __generateNode(node.right);\n      // assign node type\n      // check types\n      node.type = util.typeCheck(node.left, node.right);\n      // error\n      if (!node.type) {\n        return __logError(node, node.location, 'type_mismatch', [node.operator, node.left.type, node.right.type]);\n      }\n      return node;\n    },\n\n    ASSIGNMENT_STATEMENT: function (node) {\n      var result = __generateNode(node.left);\n      // eval asignment right hand side\n      result += ' = ' + __generateNode(node.right);\n      return result;\n    },\n\n    BLOCK_STATEMENT: function (node) {\n      var result = ' {\\n';\n\n      indentManager.increase();\n\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item) + ';\\n';\n      });\n\n      indentManager.decrease();\n      \n      result += '}\\n';\n\n      return result;\n    },\n\n    PROGRAM: function (node) {\n      var result = '';\n      node.body.forEach(function(item) {\n        result += indentManager.getCurrentIndent() + __generateNode(item);\n        if (!result.match(/\\}\\n$/)) {\n          result += ';';\n        }\n        result += '\\n';\n      });\n      \n      return result;\n    },\n\n    IF_STATEMENT: function (node) {\n\n      var result = ' if ( ';\n\n      result += __generateNode(node.test);\n\n      result += ' ) ';\n      \n      result += __generateNode(node.consequent);\n\n      if (node.alternate) {\n      result += ' else ';\n        result += __generateNode(node.alternate);\n      }\n      return result;\n    },\n\n    LOGICAL_EXPRESSION: function (node) {\n      node.left = __generateNode(node.left);\n      node.right = __generateNode(node.right);\n\n      var result = node.left + ' ' + node.operator + ' ' + node.right;\n      return result;\n    },\n\n    UPDATE_EXPRESSION: function (node) {\n      node.argument = __generateNode(node.argument);\n      if (!util.isNumber(node.argument.type)) {\n        // error\n        return __logError(node, node.location, 'not_a_number');\n      }\n      node.type = node.argument.type; \n      return node;\n    },\n\n    UNARY_EXPRESSION: function (node) {\n      node.argument = __generateNode(node.argument);\n      var cType = util.typeCheck(node.argument);\n      if (cType !== 'bool') {\n        // error\n        return __logError(node, node.location, 'not_a_bool');\n      }\n      return node;\n    }\n\n  };\n\n  // :: SPARK EVALUATOR\n\n  return {\n    parse: function (tree) {\n      console.log('tree 2:')\n      console.log(tree)\n\n      var code = __generateNode(tree);\n      return code.trim();\n    }\n  };\n\n})(this);"],"sourceRoot":"/source/"}